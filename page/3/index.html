<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-zookeeper集群服务启动流程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/03/zookeeper%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2018-09-03T13:06:04.000Z" itemprop="datePublished">2018-09-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/zookeeper/">zookeeper</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/03/zookeeper%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">zookeeper集群服务启动流程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="启动流程图"><a href="#启动流程图" class="headerlink" title="启动流程图"></a>启动流程图</h1><p><img src="http://file.ornobug.top/zookeeper%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="zookeeper集群服务启动流程图" title="zookeeper集群服务启动流程图"></p>
<h1 id="预启动"><a href="#预启动" class="headerlink" title="预启动"></a>预启动</h1><ul>
<li><code>QuorumPeerMain</code>启动</li>
<li>解析配置文件<code>zoo.cfg</code></li>
<li>创建并启动历史文件清理器<code>DataDirCleanupManager</code></li>
<li>判断单机/集群模式，本次集群模式，所以走集群启动分支</li>
</ul>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runFromConfig</span><span class="params">(QuorumPeerConfig config)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ManagedUtil.registerLog4jMBeans();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JMException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Unable to register log4j JMX control&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG.info(<span class="string">&quot;Starting quorum peer&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建ServerCnxnFactory</span></span><br><span class="line">        ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">        <span class="comment">// 初始化ServerCnxnFactory</span></span><br><span class="line">        cnxnFactory.configure(config.getClientPortAddress(),</span><br><span class="line">                config.getMaxClientCnxns());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建QuorumPeer实例</span></span><br><span class="line">        quorumPeer = getQuorumPeer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置服务列表</span></span><br><span class="line">        quorumPeer.setQuorumPeers(config.getServers());</span><br><span class="line">        <span class="comment">// 创建FileTxnSnapLog实例，并为quorumPeer设置FileTxnSnapLog</span></span><br><span class="line">        quorumPeer.setTxnFactory(<span class="keyword">new</span> FileTxnSnapLog(</span><br><span class="line">                <span class="keyword">new</span> File(config.getDataLogDir()),</span><br><span class="line">                <span class="keyword">new</span> File(config.getDataDir())));</span><br><span class="line">        <span class="comment">// 初始化quorumPeer</span></span><br><span class="line">        <span class="comment">// Leader选举算法</span></span><br><span class="line">        quorumPeer.setElectionType(config.getElectionAlg());</span><br><span class="line">        quorumPeer.setMyid(config.getServerId());</span><br><span class="line">        quorumPeer.setTickTime(config.getTickTime());</span><br><span class="line">        quorumPeer.setInitLimit(config.getInitLimit());</span><br><span class="line">        quorumPeer.setSyncLimit(config.getSyncLimit());</span><br><span class="line">        <span class="comment">// 是否监听所有可用ip地址的请求，而不是仅仅监听配置文件配置的ip，默认false</span></span><br><span class="line">        quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());</span><br><span class="line">        quorumPeer.setCnxnFactory(cnxnFactory);</span><br><span class="line">        quorumPeer.setQuorumVerifier(config.getQuorumVerifier());</span><br><span class="line">        quorumPeer.setClientPortAddress(config.getClientPortAddress());</span><br><span class="line">        quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());</span><br><span class="line">        quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());</span><br><span class="line">        <span class="comment">// 创建内存数据库，并为quorumPeer设值</span></span><br><span class="line">        quorumPeer.setZKDatabase(<span class="keyword">new</span> ZKDatabase(quorumPeer.getTxnFactory()));</span><br><span class="line">        <span class="comment">// 设置参与者类型:PARTICIPANT(一般的follower角色,OBSERVER(观察者角色)</span></span><br><span class="line">        quorumPeer.setLearnerType(config.getPeerType());</span><br><span class="line">        quorumPeer.setSyncEnabled(config.getSyncEnabled());</span><br><span class="line">        <span class="comment">// 设置认证相关信息</span></span><br><span class="line">        <span class="comment">// sets quorum sasl authentication configurations</span></span><br><span class="line">        quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);</span><br><span class="line">        <span class="keyword">if</span> (quorumPeer.isQuorumSaslAuthEnabled()) &#123;</span><br><span class="line">            quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);</span><br><span class="line">            quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);</span><br><span class="line">            quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);</span><br><span class="line">            quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);</span><br><span class="line">            quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置每个quorumPeer能连接的客户端的最大数量</span></span><br><span class="line">        quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);</span><br><span class="line">        <span class="comment">// 认证相关初始化</span></span><br><span class="line">        quorumPeer.initialize();</span><br><span class="line"></span><br><span class="line">        quorumPeer.start();</span><br><span class="line">        quorumPeer.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// warn, but generally this is ok</span></span><br><span class="line">        LOG.warn(<span class="string">&quot;Quorum Peer interrupted&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// QuorumPeer#start()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 恢复本地数据</span></span><br><span class="line">    loadDataBase();</span><br><span class="line">    <span class="comment">// 启动ServerCnxnFactory线程</span></span><br><span class="line">    cnxnFactory.start();    </span><br><span class="line">    <span class="comment">// Leader选举    </span></span><br><span class="line">    startLeaderElection();</span><br><span class="line">    <span class="keyword">super</span>.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化步骤如下:</p>
<ul>
<li>创建ServerCnxnFactory</li>
<li>初始化ServerCnxnFactory</li>
<li>创建FileTxnSnapLog实例，并为quorumPeer设置FileTxnSnapLog</li>
<li>创建QuorumPeer实例,Quorum是集群模式下的特有对象，是<code>ZooKeeperServer</code>实例的托管者。从集群层面看<code>QuorumPeer</code>代表了集群中一台zookeeper机器。在运行期间，<code>QuorumPeer</code>会不断的检测服务器实例的运行状态，同时根据情况发起Leader选举。、</li>
<li>创建内存数据库，并为quorumPeer设值</li>
<li>quorumPeer设置必要配置信息</li>
<li>完成quorumPeer认证相关的初始化</li>
<li>恢复本地数据</li>
<li>启动ServerCnxnFactory线程</li>
</ul>
<h1 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h1><h2 id="初始化Leader选举"><a href="#初始化Leader选举" class="headerlink" title="初始化Leader选举"></a>初始化Leader选举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QuorumPeer#startLeaderElection()</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startLeaderElection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构造投票</span></span><br><span class="line">		currentVote = <span class="keyword">new</span> Vote(myid, getLastLoggedZxid(), getCurrentEpoch());</span><br><span class="line">	&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">		RuntimeException re = <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">		re.setStackTrace(e.getStackTrace());</span><br><span class="line">		<span class="keyword">throw</span> re;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 设置当前服务的客户端连接地址</span></span><br><span class="line">    <span class="keyword">for</span> (QuorumServer p : getView().values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.id == myid) &#123;</span><br><span class="line">            myQuorumAddr = p.addr;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (myQuorumAddr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;My id &quot;</span> + myid + <span class="string">&quot; not in the peer list&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (electionType == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            udpSocket = <span class="keyword">new</span> DatagramSocket(myQuorumAddr.getPort());</span><br><span class="line">            responder = <span class="keyword">new</span> ResponderThread();</span><br><span class="line">            responder.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建选举算法</span></span><br><span class="line">    <span class="keyword">this</span>.electionAlg = createElectionAlgorithm(electionType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// QuorumPeer#createElectionAlgorithm()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Election <span class="title">createElectionAlgorithm</span><span class="params">(<span class="keyword">int</span> electionAlgorithm)</span></span>&#123;</span><br><span class="line">    Election le=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> use a factory rather than a switch</span></span><br><span class="line">    <span class="keyword">switch</span> (electionAlgorithm) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        le = <span class="keyword">new</span> LeaderElection(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="comment">// 创建QuorumCnxnManager</span></span><br><span class="line">        qcm = createCnxnManager();</span><br><span class="line">        <span class="comment">// 设置选举监听器</span></span><br><span class="line">        QuorumCnxManager.Listener listener = qcm.listener;</span><br><span class="line">        <span class="keyword">if</span>(listener != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 选举监听器启动</span></span><br><span class="line">            listener.start();</span><br><span class="line">            <span class="comment">// 构造选举算法</span></span><br><span class="line">            le = <span class="keyword">new</span> FastLeaderElection(<span class="keyword">this</span>, qcm);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Null listener when initializing cnx manager&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> le;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里做了几件事</p>
<ul>
<li>构造投票，先给自己投一票</li>
<li>设置当前服务的客户端连接地址</li>
<li>创建选举网络I/O层<code>QuorumCnxnManager</code></li>
<li>设置选举监听器并启动</li>
<li>构造选举算法，3.4.0.以后版本只支持<code>FastLeaderElection</code>选举算法</li>
</ul>
<h2 id="检测服务运行状态"><a href="#检测服务运行状态" class="headerlink" title="检测服务运行状态"></a>检测服务运行状态</h2><p><code>QuorumPeer</code>是<code>ZooKeeperServer</code>实例的托管者，在运行期间，<code>QuorumPeer</code>核心工作就是不断检测当前服务器的状态，并作出相应处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QuorumPeer#run()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setName(<span class="string">&quot;QuorumPeer&quot;</span> + <span class="string">&quot;[myid=&quot;</span> + getId() + <span class="string">&quot;]&quot;</span> +</span><br><span class="line">            cnxnFactory.getLocalAddress());</span><br><span class="line"></span><br><span class="line">    LOG.debug(<span class="string">&quot;Starting quorum peer&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// QuorumPeer注册为JMX服务</span></span><br><span class="line">        jmxQuorumBean = <span class="keyword">new</span> QuorumBean(<span class="keyword">this</span>);</span><br><span class="line">        MBeanRegistry.getInstance().register(jmxQuorumBean, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">for</span>(QuorumServer s: getView().values())&#123;</span><br><span class="line">            ZKMBeanInfo p;</span><br><span class="line">            <span class="keyword">if</span> (getId() == s.id) &#123;</span><br><span class="line">                p = jmxLocalPeerBean = <span class="keyword">new</span> LocalPeerBean(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    MBeanRegistry.getInstance().register(p, jmxQuorumBean);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">&quot;Failed to register with JMX&quot;</span>, e);</span><br><span class="line">                    jmxLocalPeerBean = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = <span class="keyword">new</span> RemotePeerBean(s);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    MBeanRegistry.getInstance().register(p, jmxQuorumBean);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">&quot;Failed to register with JMX&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Failed to register with JMX&quot;</span>, e);</span><br><span class="line">        jmxQuorumBean = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Main loop</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (getPeerState()) &#123;</span><br><span class="line">            <span class="keyword">case</span> LOOKING:</span><br><span class="line">                LOG.info(<span class="string">&quot;LOOKING&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;readonlymode.enabled&quot;</span>)) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        setBCVote(<span class="keyword">null</span>);</span><br><span class="line">                        setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OBSERVING:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FOLLOWING:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    LOG.info(<span class="string">&quot;FOLLOWING&quot;</span>);</span><br><span class="line">                    setFollower(makeFollower(logFactory));</span><br><span class="line">                    follower.followLeader();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>,e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    follower.shutdown();</span><br><span class="line">                    setFollower(<span class="keyword">null</span>);</span><br><span class="line">                    setPeerState(ServerState.LOOKING);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEADING:</span><br><span class="line">                LOG.info(<span class="string">&quot;LEADING&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    setLeader(makeLeader(logFactory));</span><br><span class="line">                    leader.lead();</span><br><span class="line">                    setLeader(<span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>,e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (leader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        leader.shutdown(<span class="string">&quot;Forcing shutdown&quot;</span>);</span><br><span class="line">                        setLeader(<span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setPeerState(ServerState.LOOKING);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;QuorumPeer main thread exited&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MBeanRegistry.getInstance().unregisterAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Failed to unregister with JMX&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        jmxQuorumBean = <span class="keyword">null</span>;</span><br><span class="line">        jmxLocalPeerBean = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>zookeeper服务器状态在<code>LOOKING</code>、<code>OBSERVING</code>、<code>FOLLOWING</code>、<code>LEADING</code>之间切换，当前是在<code>LOOKING</code>，所以会开始选举。</p>
<h2 id="Leader选举-1"><a href="#Leader选举-1" class="headerlink" title="Leader选举"></a>Leader选举</h2><p>Leader选举过程:集群中所有机器相互之间进行一系列投票，选举产生最合适的机器成为<code>Leader</code>，其余机器成为<code>Follower</code>或<code>Observer</code>的初始化过程。集群中哪个机器的数据越新(ZXID越大表示数据越新)，越有可能成为<code>Leader</code>。如果<code>ZXID</code>一致，那么<code>SID</code>最大的成为<code>Leader</code>。</p>
<h1 id="Leader和Follower启动期交互过程"><a href="#Leader和Follower启动期交互过程" class="headerlink" title="Leader和Follower启动期交互过程"></a>Leader和Follower启动期交互过程</h1><p>交互流程如图</p>
<p><img src="http://file.ornobug.top/zookeeper%E5%90%AF%E5%8A%A8%E6%9C%9FLeader%E5%92%8CFollower%E4%BA%A4%E4%BA%92.png" alt="Leader和Follower启动期交互过程" title="Leader和Follower启动期交互过程"></p>
<p>在选举结束后，每个节点的状态会在<code>FOLLOWING</code>或<code>LEADING</code>，Leader服务器会进行如下操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QuorumPeer#run()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Main loop</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (getPeerState()) &#123;</span><br><span class="line">            <span class="keyword">case</span> LOOKING:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OBSERVING:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FOLLOWING:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    LOG.info(<span class="string">&quot;FOLLOWING&quot;</span>);</span><br><span class="line">                    <span class="comment">// 创建follower实例</span></span><br><span class="line">                    setFollower(makeFollower(logFactory));</span><br><span class="line">                    <span class="comment">// 开始follow操作</span></span><br><span class="line">                    follower.followLeader();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>,e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    follower.shutdown();</span><br><span class="line">                    setFollower(<span class="keyword">null</span>);</span><br><span class="line">                    setPeerState(ServerState.LOOKING);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEADING:</span><br><span class="line">                LOG.info(<span class="string">&quot;LEADING&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 创建leader</span></span><br><span class="line">                    setLeader(makeLeader(logFactory));</span><br><span class="line">                    <span class="comment">// 开始lead操作</span></span><br><span class="line">                    leader.lead();</span><br><span class="line">                    setLeader(<span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>,e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (leader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        leader.shutdown(<span class="string">&quot;Forcing shutdown&quot;</span>);</span><br><span class="line">                        setLeader(<span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setPeerState(ServerState.LOOKING);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;QuorumPeer main thread exited&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MBeanRegistry.getInstance().unregisterAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Failed to unregister with JMX&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        jmxQuorumBean = <span class="keyword">null</span>;</span><br><span class="line">        jmxLocalPeerBean = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建Leader和Follower"><a href="#创建Leader和Follower" class="headerlink" title="创建Leader和Follower"></a>创建Leader和Follower</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QuorumPeer#makeFollower()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Follower <span class="title">makeFollower</span><span class="params">(FileTxnSnapLog logFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Follower(<span class="keyword">this</span>, <span class="keyword">new</span> FollowerZooKeeperServer(logFactory,</span><br><span class="line">            <span class="keyword">this</span>,<span class="keyword">new</span> ZooKeeperServer.BasicDataTreeBuilder(), <span class="keyword">this</span>.zkDb));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// QuorumPeer#makeLeader()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Leader <span class="title">makeLeader</span><span class="params">(FileTxnSnapLog logFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Leader(<span class="keyword">this</span>, <span class="keyword">new</span> LeaderZooKeeperServer(logFactory,</span><br><span class="line">            <span class="keyword">this</span>,<span class="keyword">new</span> ZooKeeperServer.BasicDataTreeBuilder(), <span class="keyword">this</span>.zkDb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Leader启动Follower接收器LearnerCnxnAcceptor"><a href="#Leader启动Follower接收器LearnerCnxnAcceptor" class="headerlink" title="Leader启动Follower接收器LearnerCnxnAcceptor"></a>Leader启动Follower接收器LearnerCnxnAcceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Leader#lead()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lead</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    self.end_fle = Time.currentElapsedTime();</span><br><span class="line">    <span class="keyword">long</span> electionTimeTaken = self.end_fle - self.start_fle;</span><br><span class="line">    self.setElectionTimeTaken(electionTimeTaken);</span><br><span class="line">    LOG.info(<span class="string">&quot;LEADING - LEADER ELECTION TOOK - &#123;&#125;&quot;</span>, electionTimeTaken);</span><br><span class="line">    self.start_fle = <span class="number">0</span>;</span><br><span class="line">    self.end_fle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将leader实例通过JMX暴露</span></span><br><span class="line">    zk.registerJMX(<span class="keyword">new</span> LeaderBean(<span class="keyword">this</span>, zk), self.jmxLocalPeerBean);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        self.tick.set(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 作为Leader要保证数据最新，要再次加载数据到内存</span></span><br><span class="line">        zk.loadData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装不同状态的比较逻辑</span></span><br><span class="line">        leaderStateSummary = <span class="keyword">new</span> StateSummary(self.getCurrentEpoch(), zk.getLastProcessedZxid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start thread that waits for connection requests from</span></span><br><span class="line">        <span class="comment">// new followers.</span></span><br><span class="line">        <span class="comment">// 创建LearnerCnxAcceptor</span></span><br><span class="line">        cnxAcceptor = <span class="keyword">new</span> LearnerCnxAcceptor();</span><br><span class="line">        <span class="comment">// 启动LearnerCnxAcceptor开始接收非leader的连接请求</span></span><br><span class="line">        cnxAcceptor.start();</span><br><span class="line"></span><br><span class="line">        readyToStart = <span class="keyword">true</span>;  </span><br><span class="line">        <span class="comment">//等待足够多的follower进来，代表自己确实是leader，此处lead线程可能会等待  </span></span><br><span class="line">        <span class="keyword">long</span> epoch = getEpochToPropose(self.getId(), self.getAcceptedEpoch());  </span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        zk.unregisterJMX(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Learner服务器开始和Leader建立连接"><a href="#Learner服务器开始和Leader建立连接" class="headerlink" title="Learner服务器开始和Leader建立连接"></a>Learner服务器开始和Leader建立连接</h2><p>所有的learner服务器在启动完毕后，会从leader选举结果中找到leader服务器，然后与其建立连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Follower#followLeader()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">followLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    self.end_fle = Time.currentElapsedTime();</span><br><span class="line">    <span class="keyword">long</span> electionTimeTaken = self.end_fle - self.start_fle;</span><br><span class="line">    self.setElectionTimeTaken(electionTimeTaken);</span><br><span class="line">    LOG.info(<span class="string">&quot;FOLLOWING - LEADER ELECTION TOOK - &#123;&#125;&quot;</span>, electionTimeTaken);</span><br><span class="line">    self.start_fle = <span class="number">0</span>;</span><br><span class="line">    self.end_fle = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将Follower通过JMX暴露</span></span><br><span class="line">    fzk.registerJMX(<span class="keyword">new</span> FollowerBean(<span class="keyword">this</span>, zk), self.jmxLocalPeerBean);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过sid获得leader服务器</span></span><br><span class="line">        QuorumServer leaderServer = findLeader();            </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 连接到leader</span></span><br><span class="line">            connectToLeader(leaderServer.addr, leaderServer.hostname);</span><br><span class="line">            <span class="comment">// 将当前learner注册到leader</span></span><br><span class="line">            <span class="keyword">long</span> newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        zk.unregisterJMX((Learner)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Learner#findLeader()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> QuorumServer <span class="title">findLeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QuorumServer leaderServer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// Find the leader by id</span></span><br><span class="line">    Vote current = self.getCurrentVote();</span><br><span class="line">    <span class="keyword">for</span> (QuorumServer s : self.getView().values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.id == current.getId()) &#123;</span><br><span class="line">            <span class="comment">// Ensure we have the leader&#x27;s correct IP address before</span></span><br><span class="line">            <span class="comment">// attempting to connect.</span></span><br><span class="line">            s.recreateSocketAddresses();</span><br><span class="line">            leaderServer = s;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leaderServer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Couldn&#x27;t find the leader with id = &quot;</span></span><br><span class="line">                + current.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leaderServer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Learner#connectToLeader()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">connectToLeader</span><span class="params">(InetSocketAddress addr, String hostname)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ConnectException, InterruptedException </span>&#123;</span><br><span class="line">    sock = <span class="keyword">new</span> Socket();        </span><br><span class="line">    sock.setSoTimeout(self.tickTime * self.initLimit);</span><br><span class="line">    <span class="comment">// 连接到leader,尝试五次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> tries = <span class="number">0</span>; tries &lt; <span class="number">5</span>; tries++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sock.connect(addr, self.tickTime * self.syncLimit);</span><br><span class="line">            sock.setTcpNoDelay(nodelay);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tries == <span class="number">4</span>) &#123;</span><br><span class="line">                LOG.error(<span class="string">&quot;Unexpected exception&quot;</span>,e);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOG.warn(<span class="string">&quot;Unexpected exception, tries=&quot;</span>+tries+</span><br><span class="line">                        <span class="string">&quot;, connecting to &quot;</span> + addr,e);</span><br><span class="line">                sock = <span class="keyword">new</span> Socket();</span><br><span class="line">                sock.setSoTimeout(self.tickTime * self.initLimit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self.authLearner.authenticate(sock, hostname);</span><br><span class="line"></span><br><span class="line">    leaderIs = BinaryInputArchive.getArchive(<span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">            sock.getInputStream()));</span><br><span class="line">    bufferedOutput = <span class="keyword">new</span> BufferedOutputStream(sock.getOutputStream());</span><br><span class="line">    leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Leader服务器创建LearnerJandler"><a href="#Leader服务器创建LearnerJandler" class="headerlink" title="Leader服务器创建LearnerJandler"></a>Leader服务器创建LearnerJandler</h2><p>leader接收到learner的连接创建请求后，会创建一个LearnerHandler。每一个LearnerHandler实例对应一个leader与learner服务器之间的连接，其负责leader与learner间几乎所有的消息通信和数据同步。<br>zookeeepr将<code>Follower</code>和<code>Observer</code>抽象出<code>Learner</code>这个父类用来统一管理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Leader$LearnerCnxAcceptor#run()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">// 线程在此等待learner连接  </span></span><br><span class="line">                Socket s = ss.accept();</span><br><span class="line">                <span class="comment">// start with the initLimit, once the ack is processed</span></span><br><span class="line">                <span class="comment">// in LearnerHandler switch to the syncLimit</span></span><br><span class="line">                <span class="comment">// 读超时设为initLimit时间</span></span><br><span class="line">                s.setSoTimeout(self.tickTime * self.initLimit);</span><br><span class="line">                s.setTcpNoDelay(nodelay);</span><br><span class="line">                <span class="comment">// 接收来自learner的连接</span></span><br><span class="line">                BufferedInputStream is = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        s.getInputStream());</span><br><span class="line">                <span class="comment">// 每一个learner的连接都会封装到一个LearnerHandler实例</span></span><br><span class="line">                <span class="comment">// 这个实例负责leader和learner之间的消息通信和数据同步</span></span><br><span class="line">                LearnerHandler fh = <span class="keyword">new</span> LearnerHandler(s, is, Leader.<span class="keyword">this</span>);</span><br><span class="line">                fh.start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Exception while accepting follower&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="向Leader注册"><a href="#向Leader注册" class="headerlink" title="向Leader注册"></a>向Leader注册</h2><p>当和leader建立起连接后，learner就会开始向leader进行注册，其实就是将learner服务器的自身信息发给leader服务器，我们称之为LearnerInfo，包括当前服务器的SID和服务器处理的最新的ZXID。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Follower#followLeader()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">followLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    self.end_fle = Time.currentElapsedTime();</span><br><span class="line">    <span class="keyword">long</span> electionTimeTaken = self.end_fle - self.start_fle;</span><br><span class="line">    self.setElectionTimeTaken(electionTimeTaken);</span><br><span class="line">    LOG.info(<span class="string">&quot;FOLLOWING - LEADER ELECTION TOOK - &#123;&#125;&quot;</span>, electionTimeTaken);</span><br><span class="line">    self.start_fle = <span class="number">0</span>;</span><br><span class="line">    self.end_fle = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将Follower通过JMX暴露</span></span><br><span class="line">    fzk.registerJMX(<span class="keyword">new</span> FollowerBean(<span class="keyword">this</span>, zk), self.jmxLocalPeerBean);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过sid获得leader服务器</span></span><br><span class="line">        QuorumServer leaderServer = findLeader();            </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 连接到leader</span></span><br><span class="line">            connectToLeader(leaderServer.addr, leaderServer.hostname);</span><br><span class="line">            <span class="comment">// 将当前learner注册到leader</span></span><br><span class="line">            <span class="keyword">long</span> newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        zk.unregisterJMX((Learner)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Learner#registerWithLeader()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">registerWithLeader</span><span class="params">(<span class="keyword">int</span> pktType)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Send follower info, including last zxid and sid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">long</span> lastLoggedZxid = self.getLastLoggedZxid();</span><br><span class="line">    QuorumPacket qp = <span class="keyword">new</span> QuorumPacket();                </span><br><span class="line">    qp.setType(pktType);</span><br><span class="line">    qp.setZxid(ZxidUtils.makeZxid(self.getAcceptedEpoch(), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Add sid to payload</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LearnerInfo li = <span class="keyword">new</span> LearnerInfo(self.getId(), <span class="number">0x10000</span>);</span><br><span class="line">    ByteArrayOutputStream bsid = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bsid);</span><br><span class="line">    boa.writeRecord(li, <span class="string">&quot;LearnerInfo&quot;</span>);</span><br><span class="line">    qp.setData(bsid.toByteArray());</span><br><span class="line">    <span class="comment">// 向leader发包</span></span><br><span class="line">    writePacket(qp, <span class="keyword">true</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Learner#writePacket()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writePacket</span><span class="params">(QuorumPacket pp, <span class="keyword">boolean</span> flush)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (leaderOs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            leaderOs.writeRecord(pp, <span class="string">&quot;packet&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            bufferedOutput.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Leader解析Learner信息，计算新的epoch"><a href="#Leader解析Learner信息，计算新的epoch" class="headerlink" title="Leader解析Learner信息，计算新的epoch"></a>Leader解析Learner信息，计算新的epoch</h2><p>leader服务器收到LearnerInfo后，会解析出该learner的SID和ZXID，根据该learner的ZXID解析出其对应的epoch_of_learner，和当前Leader服务器的epoch_of_learner进行比较，如果该learner的epoch_of_learner更大，那么就更新leader的epoch：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">epoch_of_leader&#x3D;epoch_of_learner+1</span><br></pre></td></tr></table></figure>
<p>然后，LearnerHandler会进行等待(阻塞在getEpochToPropose函数)，直到过半的learner进行了注册，同时更新了epoch_of_leader之后，leader就可以确定当前集群的epoch了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LearnerHandler#run()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 向把当前的learner注册到leader</span></span><br><span class="line">        leader.addLearnerHandler(<span class="keyword">this</span>);</span><br><span class="line">        tickOfNextAckDeadline = leader.self.tick.get()</span><br><span class="line">                + leader.self.initLimit + leader.self.syncLimit;</span><br><span class="line">        <span class="comment">// 这里的bufferedInput是socket.getInputStream()</span></span><br><span class="line">        <span class="comment">// IO线程等待follower发送包(LearnerInfo)</span></span><br><span class="line">        ia = BinaryInputArchive.getArchive(bufferedInput);</span><br><span class="line">        bufferedOutput = <span class="keyword">new</span> BufferedOutputStream(sock.getOutputStream());</span><br><span class="line">        oa = BinaryOutputArchive.getArchive(bufferedOutput);</span><br><span class="line"></span><br><span class="line">        QuorumPacket qp = <span class="keyword">new</span> QuorumPacket();</span><br><span class="line">        <span class="comment">// 读取从learner发过来的包</span></span><br><span class="line">        ia.readRecord(qp, <span class="string">&quot;packet&quot;</span>);</span><br><span class="line">        <span class="comment">// 只处理follower和observer</span></span><br><span class="line">        <span class="keyword">if</span>(qp.getType() != Leader.FOLLOWERINFO &amp;&amp; qp.getType() != Leader.OBSERVERINFO)&#123;</span><br><span class="line">        	LOG.error(<span class="string">&quot;First packet &quot;</span> + qp.toString()</span><br><span class="line">                    + <span class="string">&quot; is not FOLLOWERINFO or OBSERVERINFO!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span> learnerInfoData[] = qp.getData();</span><br><span class="line">        <span class="keyword">if</span> (learnerInfoData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (learnerInfoData.length == <span class="number">8</span>) &#123;</span><br><span class="line">        		ByteBuffer bbsid = ByteBuffer.wrap(learnerInfoData);</span><br><span class="line">        		<span class="keyword">this</span>.sid = bbsid.getLong();</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 反序列化LearnerInfo</span></span><br><span class="line">        		LearnerInfo li = <span class="keyword">new</span> LearnerInfo();</span><br><span class="line">        		ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(learnerInfoData), li);</span><br><span class="line">        		<span class="keyword">this</span>.sid = li.getServerid();</span><br><span class="line">        		<span class="keyword">this</span>.version = li.getProtocolVersion();</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="keyword">this</span>.sid = leader.followerCounter.getAndDecrement();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG.info(<span class="string">&quot;Follower sid: &quot;</span> + sid + <span class="string">&quot; : info : &quot;</span></span><br><span class="line">                + leader.self.quorumPeers.get(sid));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qp.getType() == Leader.OBSERVERINFO) &#123;</span><br><span class="line">              learnerType = LearnerType.OBSERVER;</span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="comment">// follower的选举轮数</span></span><br><span class="line">        <span class="keyword">long</span> lastAcceptedEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> peerLastZxid;</span><br><span class="line">        StateSummary ss = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">long</span> zxid = qp.getZxid();</span><br><span class="line">        <span class="comment">// 直到过半的learner进行了注册</span></span><br><span class="line">        <span class="keyword">long</span> newEpoch = leader.getEpochToPropose(<span class="keyword">this</span>.getSid(), lastAcceptedEpoch);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Leader#getEpochToPropose()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getEpochToPropose</span><span class="params">(<span class="keyword">long</span> sid, <span class="keyword">long</span> lastAcceptedEpoch)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;  </span><br><span class="line">    <span class="keyword">synchronized</span>(connectingFollowers) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!waitingForNewEpoch) &#123;  </span><br><span class="line">            <span class="keyword">return</span> epoch;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 根据该learner的ZXID解析出其对应的epoch_of_learner，和当前Leader服务器的epoch_of_learner进行比较</span></span><br><span class="line">        <span class="comment">// 如果该learner的epoch_of_learner更大，那么就更新leader的epoch</span></span><br><span class="line">        <span class="keyword">if</span> (lastAcceptedEpoch &gt;= epoch) &#123;  </span><br><span class="line">            epoch = lastAcceptedEpoch+<span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//将当前Learner的sid加入连接队伍中，方便后续判断lead是否有效  </span></span><br><span class="line">        connectingFollowers.add(sid);  </span><br><span class="line">        QuorumVerifier verifier = self.getQuorumVerifier();  </span><br><span class="line">        <span class="comment">//如果足够多的follower进入，选举有效，则无需等待，并通知其他的等待线程，类似于Barrier  </span></span><br><span class="line">        <span class="keyword">if</span> (connectingFollowers.contains(self.getId()) &amp;&amp;   </span><br><span class="line">            verifier.containsQuorum(connectingFollowers)) &#123;  </span><br><span class="line">            waitingForNewEpoch = <span class="keyword">false</span>;  </span><br><span class="line">            self.setAcceptedEpoch(epoch);  </span><br><span class="line">            connectingFollowers.notifyAll();  </span><br><span class="line">        &#125;  <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">//如果进入的follower不够，则进入等待，超时即为initLimit时间，  </span></span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();  </span><br><span class="line">            <span class="keyword">long</span> cur = start;  </span><br><span class="line">            <span class="keyword">long</span> end = start + self.getInitLimit()*self.getTickTime();  </span><br><span class="line">            <span class="keyword">while</span>(waitingForNewEpoch &amp;&amp; cur &lt; end) &#123;  </span><br><span class="line">                connectingFollowers.wait(end - cur);  </span><br><span class="line">                cur = System.currentTimeMillis();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//超时了，退出lead过程，重新发起选举  </span></span><br><span class="line">            <span class="keyword">if</span> (waitingForNewEpoch) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(<span class="string">&quot;Timeout while waiting for epoch from quorum&quot;</span>);          </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> epoch;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送Leader状态"><a href="#发送Leader状态" class="headerlink" title="发送Leader状态"></a>发送Leader状态</h2><p>计算出新的epoch，leader会将该信息以一个LEADERINFO消息的形式发给learner，同时等待learner响应</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LearnerHandler#run()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.getVersion() &lt; <span class="number">0x10000</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是旧版本leader</span></span><br><span class="line">        <span class="comment">// we are going to have to extrapolate the epoch information</span></span><br><span class="line">        <span class="keyword">long</span> epoch = ZxidUtils.getEpochFromZxid(zxid);</span><br><span class="line">        ss = <span class="keyword">new</span> StateSummary(epoch, zxid);</span><br><span class="line">        <span class="comment">// fake the message</span></span><br><span class="line">        leader.waitForEpochAck(<span class="keyword">this</span>.getSid(), ss);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 最新版的leader</span></span><br><span class="line">        <span class="comment">// 因为在构造LearnerInfo时传递的version就是0x10000</span></span><br><span class="line">        <span class="comment">// e而且在反序列化leaderInfo信息时会将version赋予给leader</span></span><br><span class="line">        <span class="comment">// 所以leader的version是0x10000</span></span><br><span class="line">        <span class="keyword">byte</span> ver[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">        ByteBuffer.wrap(ver).putInt(<span class="number">0x10000</span>);</span><br><span class="line">        <span class="comment">// 发一个Leader.LEADERINFO包，带上新的zxid</span></span><br><span class="line">        <span class="comment">// 这个zxid高32位是新的epoch值，低32位全是0  </span></span><br><span class="line">        QuorumPacket newEpochPacket = <span class="keyword">new</span> QuorumPacket(Leader.LEADERINFO, ZxidUtils.makeZxid(newEpoch, <span class="number">0</span>), ver, <span class="keyword">null</span>);</span><br><span class="line">        oa.writeRecord(newEpochPacket, <span class="string">&quot;packet&quot;</span>);</span><br><span class="line">        bufferedOutput.flush();</span><br><span class="line">        QuorumPacket ackEpochPacket = <span class="keyword">new</span> QuorumPacket();</span><br><span class="line">        <span class="comment">// 等待follower响应，对应下边的接收到ack消息</span></span><br><span class="line">        ia.readRecord(ackEpochPacket, <span class="string">&quot;packet&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ackEpochPacket.getType() != Leader.ACKEPOCH) &#123;</span><br><span class="line">            LOG.error(ackEpochPacket.toString()</span><br><span class="line">                    + <span class="string">&quot; is not ACKEPOCH&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">        ByteBuffer bbepoch = ByteBuffer.wrap(ackEpochPacket.getData());</span><br><span class="line">        ss = <span class="keyword">new</span> StateSummary(bbepoch.getInt(), ackEpochPacket.getZxid());</span><br><span class="line">        <span class="comment">// 过半阻塞，必须要收到集群中过半机器的EpochAck才能继续</span></span><br><span class="line">        leader.waitForEpochAck(<span class="keyword">this</span>.getSid(), ss);</span><br><span class="line">    &#125;</span><br><span class="line">    peerLastZxid = ss.getLastZxid();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Leader#waitForEpochAck()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitForEpochAck</span><span class="params">(<span class="keyword">long</span> id, StateSummary ss)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(electingFollowers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (electionFinished) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ss.getCurrentEpoch() != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ss.isMoreRecentThan(leaderStateSummary)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Follower is ahead of the leader, leader summary: &quot;</span></span><br><span class="line">                                                + leaderStateSummary.getCurrentEpoch()</span><br><span class="line">                                                + <span class="string">&quot; (current epoch), &quot;</span></span><br><span class="line">                                                + leaderStateSummary.getLastZxid()</span><br><span class="line">                                                + <span class="string">&quot; (last zxid)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isParticipant(id)) &#123;</span><br><span class="line">                <span class="comment">// 将当前learner的sid添加到等待集合</span></span><br><span class="line">                electingFollowers.add(id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        QuorumVerifier verifier = self.getQuorumVerifier();</span><br><span class="line">        <span class="comment">// 判断是否满足选举条件，如果不满足进入等待，满足则通知其他等待线程</span></span><br><span class="line">        <span class="keyword">if</span> (electingFollowers.contains(self.getId()) &amp;&amp; verifier.containsQuorum(electingFollowers)) &#123;</span><br><span class="line">            electionFinished = <span class="keyword">true</span>;</span><br><span class="line">            electingFollowers.notifyAll();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;     </span><br><span class="line">            <span class="comment">// follower还不够，等等吧             </span></span><br><span class="line">            <span class="keyword">long</span> start = Time.currentElapsedTime();</span><br><span class="line">            <span class="keyword">long</span> cur = start;</span><br><span class="line">            <span class="keyword">long</span> end = start + self.getInitLimit()*self.getTickTime();</span><br><span class="line">            <span class="keyword">while</span>(!electionFinished &amp;&amp; cur &lt; end) &#123;</span><br><span class="line">                electingFollowers.wait(end - cur);</span><br><span class="line">                cur = Time.currentElapsedTime();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!electionFinished) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(<span class="string">&quot;Timeout while waiting for epoch to be acked by quorum&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ZxidUtils#makeZxid()</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">makeZxid</span><span class="params">(<span class="keyword">long</span> epoch, <span class="keyword">long</span> counter)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (epoch &lt;&lt; <span class="number">32L</span>) | (counter &amp; <span class="number">0xffffffffL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Learner接收Leader-LEADERINFO包并返回ACK包"><a href="#Learner接收Leader-LEADERINFO包并返回ACK包" class="headerlink" title="Learner接收Leader.LEADERINFO包并返回ACK包"></a>Learner接收<code>Leader.LEADERINFO</code>包并返回<code>ACK</code>包</h2><p>follower在收到来自leader的LEADERINFO消息后，会解析出epoch和ZXID，然后向Leader反馈一个ACKEPOCH响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Learner#registerWithLeader()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">registerWithLeader</span><span class="params">(<span class="keyword">int</span> pktType)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    readPacket(qp);    </span><br><span class="line">    <span class="comment">// zxid 右移32位得到新的epochid    </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> newEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());</span><br><span class="line">	<span class="keyword">if</span> (qp.getType() == Leader.LEADERINFO) &#123;</span><br><span class="line">    	<span class="comment">// we are connected to a 1.0 server so accept the new epoch and read the next packet</span></span><br><span class="line">        <span class="comment">// 接收leader发过来的Leader.LEADERINFO包</span></span><br><span class="line">    	leaderProtocolVersion = ByteBuffer.wrap(qp.getData()).getInt();</span><br><span class="line">        <span class="comment">// leaderProtocolVersion=0x10000</span></span><br><span class="line">    	<span class="keyword">byte</span> epochBytes[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">    	<span class="keyword">final</span> ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);</span><br><span class="line">    	<span class="keyword">if</span> (newEpoch &gt; self.getAcceptedEpoch()) &#123;</span><br><span class="line">    		wrappedEpochBytes.putInt((<span class="keyword">int</span>)self.getCurrentEpoch());</span><br><span class="line">    		self.setAcceptedEpoch(newEpoch);</span><br><span class="line">    	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newEpoch == self.getAcceptedEpoch()) &#123;</span><br><span class="line">    		<span class="comment">// since we have already acked an epoch equal to the leaders, we cannot ack</span></span><br><span class="line">    		<span class="comment">// again, but we still need to send our lastZxid to the leader so that we can</span></span><br><span class="line">    		<span class="comment">// sync with it if it does assume leadership of the epoch.</span></span><br><span class="line">    		<span class="comment">// the -1 indicates that this reply should not count as an ack for the new epoch</span></span><br><span class="line">            wrappedEpochBytes.putInt(-<span class="number">1</span>);</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		<span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Leaders epoch, &quot;</span> + newEpoch + <span class="string">&quot; is less than accepted epoch, &quot;</span> + self.getAcceptedEpoch());</span><br><span class="line">    	&#125;</span><br><span class="line">    	QuorumPacket ackNewEpoch = <span class="keyword">new</span> QuorumPacket(Leader.ACKEPOCH, lastLoggedZxid, epochBytes, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 向leader发送ack包</span></span><br><span class="line">        writePacket(ackNewEpoch, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 返回新的zxid</span></span><br><span class="line">        <span class="keyword">return</span> ZxidUtils.makeZxid(newEpoch, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (newEpoch &gt; self.getAcceptedEpoch()) &#123;</span><br><span class="line">    		self.setAcceptedEpoch(newEpoch);</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">if</span> (qp.getType() != Leader.NEWLEADER) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;First packet should have been NEWLEADER&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;First packet should have been NEWLEADER&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> qp.getZxid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>leader服务器接收到learner的这个ACK消息后，就可以开始与其进行数据同步了</p>
<h1 id="启动leader和learner服务器"><a href="#启动leader和learner服务器" class="headerlink" title="启动leader和learner服务器"></a>启动leader和learner服务器</h1><p>当有过半的learner已经完成了数据同步，那么leader和learner服务器实例就可以开始启动了。<code>Leader</code>和<code>Learner</code>服务器的启动类似于单机中<code>ZooKeeperServer</code>的启动</p>
<ul>
<li><code>LeaderZooKeeperServer</code>和<code>LearnerZooKeeperServer</code>分别创建并启动会话管理器<code>SessionTrackerImpl</code></li>
<li><code>LeaderZooKeeperServer</code>和<code>LearnerZooKeeperServer</code>分别初始化<code>RequestProcessor</code>链</li>
<li><code>LeaderZooKeeperServer</code>和<code>LearnerZooKeeperServer</code>分别注册JMX服务</li>
</ul>
<p>#启动完成</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/09/03/zookeeper%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" data-id="ckjr4ve0x009df0uk9blkc739" data-title="zookeeper集群服务启动流程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/" rel="tag">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-zookeeper心跳机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/02/zookeeper%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2018-09-02T13:06:04.000Z" itemprop="datePublished">2018-09-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/zookeeper/">zookeeper</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/02/zookeeper%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/">zookeeper心跳机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>心跳机制是 <strong>客户端向服务端</strong> 发送<code>PING</code>操作的请求，确保该会话仍然可用的过程。</p>
<p>先看下请求的处理链</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LeaderZookeeperServer#setupRequestProcessors()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</span><br><span class="line">    RequestProcessor toBeAppliedProcessor = <span class="keyword">new</span> Leader.ToBeAppliedRequestProcessor(</span><br><span class="line">            finalProcessor, getLeader().toBeApplied);</span><br><span class="line">    commitProcessor = <span class="keyword">new</span> CommitProcessor(toBeAppliedProcessor,</span><br><span class="line">            Long.toString(getServerId()), <span class="keyword">false</span>,</span><br><span class="line">            getZooKeeperServerListener());</span><br><span class="line">    commitProcessor.start();</span><br><span class="line">    ProposalRequestProcessor proposalProcessor = <span class="keyword">new</span> ProposalRequestProcessor(<span class="keyword">this</span>,</span><br><span class="line">            commitProcessor);</span><br><span class="line">    proposalProcessor.initialize();</span><br><span class="line">    firstProcessor = <span class="keyword">new</span> PrepRequestProcessor(<span class="keyword">this</span>, proposalProcessor);</span><br><span class="line">    ((PrepRequestProcessor)firstProcessor).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2018/09/02/zookeeper%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/09/02/zookeeper%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/" data-id="ckjr4vdzd002kf0uk7e9d8wzz" data-title="zookeeper心跳机制" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/" rel="tag">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-zookeeper中的会话相关组件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/01/zookeeper%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6/" class="article-date">
  <time class="dt-published" datetime="2018-09-01T13:06:04.000Z" itemprop="datePublished">2018-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/zookeeper/">zookeeper</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/01/zookeeper%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6/">zookeeper中的会话相关组件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Zookeeper的连接与会话是客户端通过实例化Zookeeper对象来实现客户端与服务端创建并保持TCP连接的过程。</p>
<h1 id="会话状态"><a href="#会话状态" class="headerlink" title="会话状态"></a>会话状态</h1><p>会话状态定义如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZooKeeper$States</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">States</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 连接中</span></span><br><span class="line">    CONNECTING,</span><br><span class="line">    <span class="comment">// 客户端已经和某个服务器建立tcp连接,在等待服务器根据客户端上传的会话信息进行&quot;匹配&quot;</span></span><br><span class="line">    <span class="comment">// 代码中没有找到设置设个状态的地方</span></span><br><span class="line">    ASSOCIATING,</span><br><span class="line">    <span class="comment">// 已连接，客户端服务端可正常通信</span></span><br><span class="line">    CONNECTED,</span><br><span class="line">    <span class="comment">// 连接到只读模式的服务端，如果非只读的客户端连接到只读的服务端，会抛异常</span></span><br><span class="line">    <span class="comment">// 客户端在初始化ZooKeeper对象的时候传入构造参数指定</span></span><br><span class="line">    <span class="comment">// 服务端在启动时读取java系统属性: readonlymode.enabled，在3.4.0之后支持，设置这个值为true，就支持只读模式</span></span><br><span class="line">    CONNECTEDREADONLY,</span><br><span class="line">    <span class="comment">// 会话关闭，显式调用Zookeeper的close方法</span></span><br><span class="line">    CLOSED,</span><br><span class="line">    <span class="comment">// 建立链接时，认证失败  </span></span><br><span class="line">    AUTH_FAILED,</span><br><span class="line">    <span class="comment">// 链接断开状态，实际会话可能并没有关闭</span></span><br><span class="line">    NOT_CONNECTED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要不是认证失败和会话关闭，那么会话就是存活的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> != CLOSED &amp;&amp; <span class="keyword">this</span> != AUTH_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不论连接到正常服务端还是只读服务端，都算连上了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == CONNECTED || <span class="keyword">this</span> == CONNECTEDREADONLY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2018/09/01/zookeeper%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/09/01/zookeeper%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6/" data-id="ckjr4ve0t008wf0uk7k7kcibv" data-title="zookeeper中的会话相关组件" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/" rel="tag">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-zookeeper服务端一次会话的创建过程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/08/28/zookeeper%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%80%E6%AC%A1%E4%BC%9A%E8%AF%9D%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2018-08-28T13:06:04.000Z" itemprop="datePublished">2018-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/zookeeper/">zookeeper</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/08/28/zookeeper%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%80%E6%AC%A1%E4%BC%9A%E8%AF%9D%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/">zookeeper服务端一次会话的创建过程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>zookeeper服务端对会话创建的处理，分为如下几个阶段:</p>
<ul>
<li>请求接收</li>
<li>会话创建</li>
<li>预处理</li>
<li>事务处理</li>
<li>事务应用</li>
<li>会话响应</li>
</ul>
<p>一步步来看吧</p>
        
          <p class="article-more-link">
            <a href="/2018/08/28/zookeeper%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%80%E6%AC%A1%E4%BC%9A%E8%AF%9D%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/08/28/zookeeper%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%80%E6%AC%A1%E4%BC%9A%E8%AF%9D%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/" data-id="ckjr4ve0z009kf0uk3d2p5n6r" data-title="zookeeper服务端一次会话的创建过程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/" rel="tag">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-zookeeper客户端一次会话的创建过程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/08/27/zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%80%E6%AC%A1%E4%BC%9A%E8%AF%9D%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2018-08-27T13:06:04.000Z" itemprop="datePublished">2018-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/zookeeper/">zookeeper</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/08/27/zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%80%E6%AC%A1%E4%BC%9A%E8%AF%9D%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/">zookeeper客户端一次会话的创建过程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h1><h2 id="初始化Zookeeper客户端"><a href="#初始化Zookeeper客户端" class="headerlink" title="初始化Zookeeper客户端"></a>初始化Zookeeper客户端</h2><p>取一个最具代表性的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">boolean</span> canBeReadOnly)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    LOG.info(<span class="string">&quot;Initiating client connection, connectString=&quot;</span> + connectString</span><br><span class="line">            + <span class="string">&quot; sessionTimeout=&quot;</span> + sessionTimeout + <span class="string">&quot; watcher=&quot;</span> + watcher);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    watchManager.defaultWatcher = watcher;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    ConnectStringParser connectStringParser = <span class="keyword">new</span> ConnectStringParser(</span><br><span class="line">            connectString);</span><br><span class="line">    HostProvider hostProvider = <span class="keyword">new</span> StaticHostProvider(</span><br><span class="line">            connectStringParser.getServerAddresses());</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    cnxn = <span class="keyword">new</span> ClientCnxn(connectStringParser.getChrootPath(),</span><br><span class="line">            hostProvider, sessionTimeout, <span class="keyword">this</span>, watchManager,</span><br><span class="line">            getClientCnxnSocket(), canBeReadOnly);</span><br><span class="line">    cnxn.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面做了三件事:</p>
<ul>
<li>设置默认Watcher</li>
<li>解析zookeeper服务端地址列表，并由<code>HostProvider</code>地址管理器管理</li>
<li>构造<code>ClientCnxn</code></li>
</ul>
<h2 id="ConnectStringParser"><a href="#ConnectStringParser" class="headerlink" title="ConnectStringParser"></a>ConnectStringParser</h2><p>进入<code>ConnectStringParser</code>构造函数看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConnectStringParser</span><span class="params">(String connectString)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// parse out chroot, if any</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">int</span> off = connectString.indexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (off &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        String chrootPath = connectString.substring(off);</span><br><span class="line">        <span class="comment">// ignore &quot;/&quot; chroot spec, same as null</span></span><br><span class="line">        <span class="keyword">if</span> (chrootPath.length() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.chrootPath = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PathUtils.validatePath(chrootPath);</span><br><span class="line">            <span class="keyword">this</span>.chrootPath = chrootPath;</span><br><span class="line">        &#125;</span><br><span class="line">        connectString = connectString.substring(<span class="number">0</span>, off);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.chrootPath = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    String hostsList[] = connectString.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String host : hostsList) &#123;</span><br><span class="line">        <span class="keyword">int</span> port = DEFAULT_PORT;</span><br><span class="line">        <span class="keyword">int</span> pidx = host.lastIndexOf(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pidx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// otherwise : is at the end of the string, ignore</span></span><br><span class="line">            <span class="keyword">if</span> (pidx &lt; host.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                port = Integer.parseInt(host.substring(pidx + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            host = host.substring(<span class="number">0</span>, pidx);</span><br><span class="line">        &#125;</span><br><span class="line">        serverAddresses.add(InetSocketAddress.createUnresolved(host, port));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很简单</p>
<ul>
<li>先检查服务端地址字符串最后有没有根目录，类似这样的<code>127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183/root</code>，最后的<code>/root</code>就是检查的根目录，有就把地址和根目录截断各自赋值</li>
<li>把服务地址封装到<code>InetSocketAddress</code>中</li>
</ul>
<h3 id="InetSocketAddress"><a href="#InetSocketAddress" class="headerlink" title="InetSocketAddress"></a>InetSocketAddress</h3><p>看下<code>InetSocketAddress</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InetSocketAddress</span> <span class="keyword">extends</span> <span class="title">SocketAddress</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Private implementation class pointed to by all public methods.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InetSocketAddressHolder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The hostname of the Socket Address</span></span><br><span class="line">        <span class="keyword">private</span> String hostname;</span><br><span class="line">        <span class="comment">// The IP address of the Socket Address</span></span><br><span class="line">        <span class="keyword">private</span> InetAddress addr;</span><br><span class="line">        <span class="comment">// The port number of the Socket Address</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">InetSocketAddressHolder</span><span class="params">(String hostname, InetAddress addr, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.hostname = hostname;</span><br><span class="line">            <span class="keyword">this</span>.addr = addr;</span><br><span class="line">            <span class="keyword">this</span>.port = port;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transient 在序列化的时候放弃这个字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> InetSocketAddressHolder holder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5076001401234631237L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private constructor for creating unresolved instances</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InetSocketAddress</span><span class="params">(<span class="keyword">int</span> port, String hostname)</span> </span>&#123;</span><br><span class="line">        holder = <span class="keyword">new</span> InetSocketAddressHolder(hostname, <span class="keyword">null</span>, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InetSocketAddress <span class="title">createUnresolved</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InetSocketAddress(checkPort(port), checkHost(host));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出其实最后是把服务端地址封装到<code>InetSocketAddress</code>的内部类<code>InetSocketAddressHolder</code>中</p>
<h2 id="构造StaticHostProvider"><a href="#构造StaticHostProvider" class="headerlink" title="构造StaticHostProvider"></a>构造StaticHostProvider</h2><p>接下来看<code>HostProvider</code>的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticHostProvider</span> <span class="keyword">implements</span> <span class="title">HostProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;InetSocketAddress&gt; serverAddresses = <span class="keyword">new</span> ArrayList&lt;InetSocketAddress&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticHostProvider</span><span class="params">(Collection&lt;InetSocketAddress&gt; serverAddresses)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 地址解析器</span></span><br><span class="line">        <span class="keyword">this</span>.resolver = <span class="keyword">new</span> Resolver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> InetAddress[] getAllByName(String name) <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">                <span class="comment">// 根据域名获得ip地址</span></span><br><span class="line">                <span class="keyword">return</span> InetAddress.getAllByName(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        init(serverAddresses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Collection&lt;InetSocketAddress&gt; serverAddresses)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (serverAddresses.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">&quot;A HostProvider may not be empty!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.serverAddresses.addAll(serverAddresses);</span><br><span class="line">        Collections.shuffle(<span class="keyword">this</span>.serverAddresses);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里是把服务地址放置到serverAddress然后进行了乱序操作，<code>HostProvider</code>是对服务地址进行了管理</p>
<h2 id="初始化ClientCnxn"><a href="#初始化ClientCnxn" class="headerlink" title="初始化ClientCnxn"></a>初始化ClientCnxn</h2><p>然后是进行了<code>ClientCnxn</code>实例的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 已经发送到服务端的并且在等待写入数据的Packet队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Packet&gt; pendingQueue = <span class="keyword">new</span> LinkedList&lt;Packet&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待发送到服务端的Packet队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Packet&gt; outgoingQueue = <span class="keyword">new</span> LinkedList&lt;Packet&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClientCnxn</span><span class="params">(String chrootPath, HostProvider hostProvider, <span class="keyword">int</span> sessionTimeout, ZooKeeper zooKeeper, ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket, <span class="keyword">boolean</span> canBeReadOnly)</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(chrootPath, hostProvider, sessionTimeout, zooKeeper, watcher,</span><br><span class="line">         clientCnxnSocket, <span class="number">0</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>], canBeReadOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClientCnxn</span><span class="params">(String chrootPath, HostProvider hostProvider, <span class="keyword">int</span> sessionTimeout, ZooKeeper zooKeeper,  ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> sessionId, <span class="keyword">byte</span>[] sessionPasswd, <span class="keyword">boolean</span> canBeReadOnly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.zooKeeper = zooKeeper;</span><br><span class="line">    <span class="keyword">this</span>.watcher = watcher;</span><br><span class="line">    <span class="keyword">this</span>.sessionId = sessionId;</span><br><span class="line">    <span class="keyword">this</span>.sessionPasswd = sessionPasswd;</span><br><span class="line">    <span class="keyword">this</span>.sessionTimeout = sessionTimeout;</span><br><span class="line">    <span class="keyword">this</span>.hostProvider = hostProvider;</span><br><span class="line">    <span class="keyword">this</span>.chrootPath = chrootPath;</span><br><span class="line"></span><br><span class="line">    connectTimeout = sessionTimeout / hostProvider.size();</span><br><span class="line">    readTimeout = sessionTimeout * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">    readOnly = canBeReadOnly;</span><br><span class="line"></span><br><span class="line">    sendThread = <span class="keyword">new</span> SendThread(clientCnxnSocket);</span><br><span class="line">    eventThread = <span class="keyword">new</span> EventThread();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ClientCnxn$SendThread</span></span><br><span class="line">SendThread(ClientCnxnSocket clientCnxnSocket) &#123;</span><br><span class="line">    <span class="keyword">super</span>(makeThreadName(<span class="string">&quot;-SendThread()&quot;</span>));</span><br><span class="line">    state = States.CONNECTING;</span><br><span class="line">    <span class="keyword">this</span>.clientCnxnSocket = clientCnxnSocket;</span><br><span class="line">    setDaemon(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ClientCnxn$EventThread</span></span><br><span class="line"><span class="comment">// 待处理的客户端事件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedBlockingQueue&lt;Object&gt; waitingEvents = <span class="keyword">new</span> LinkedBlockingQueue&lt;Object&gt;();</span><br><span class="line">EventThread() &#123;</span><br><span class="line">    <span class="keyword">super</span>(makeThreadName(<span class="string">&quot;-EventThread&quot;</span>));</span><br><span class="line">    setDaemon(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的几个参数说明下:</p>
<ul>
<li>chrootPath:根节点，或者命名空间</li>
<li>hostProvider:服务地址管理器</li>
<li>sessionTimeout:会话超时时间，如果在这个时间内，服务端与客户端的心跳检测失败，就会话失效</li>
<li>zooKeeper:zookeeper客户端</li>
<li>watcher:客户端Watcher管理器，管理这这条到服务端的连接上的客户端Watcher</li>
<li>clientCnxnSocket:clientCnxn的I/O连接器</li>
<li>sessionId:会话id，默认0</li>
<li>sessionPasswd:会话密钥，默认为长度16的空byte数组</li>
<li>canBeReadOnly:（在3.4中添加）是否允许创建的客户端在分区的情况下进入只读模式。 只读模式基本上意味着如果客户端找不到任何多数服务器但是它可以到达分区服务器，它会以只读模式连接到一个，即允许读请求而写请求不是。 它继续在后台寻求大多数。</li>
<li>connectTimeout:<code>sessionTimeout / hostProvider.size();</code>表明如果zookeeper服务端越多，zookeeper期望客户端连接到服务端的时间越短</li>
<li>readTimeout:<code>sessionTimeout * 2 / 3;</code>zookeeper期望客户端读数据的超时时间最长不要超过会话超时时间的2/3<br>方法最后就是初始化了<code>SendThread</code>和<code>EventThread</code>，并会把这两个线程设置为<strong>守护线程</strong>。<code>SendThread</code>负责管理客户端和服务端的所有网络I/O，<code>EventThread</code>负责客户端的事件处理。zookeeper客户端会把<code>ClientCnxnSocket</code>分配给<code>SendThread</code>作为底层的I/O处理器。<code>EventThread</code>在初始化的时候还会初始化待处理的事件队列waitingEvents，其存放待处理的客户端事件。</li>
</ul>
<h1 id="会话创建阶段"><a href="#会话创建阶段" class="headerlink" title="会话创建阶段"></a>会话创建阶段</h1><h2 id="启动ClientCnxn"><a href="#启动ClientCnxn" class="headerlink" title="启动ClientCnxn"></a>启动ClientCnxn</h2><p>在构造完<code>ClientCnxn</code>后就会启动了<code>cnxn.start();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxn#start()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sendThread.start();</span><br><span class="line">    eventThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程开始执行了，我们看下<code>SendThread</code>的run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxn$SendThread#run()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置clientCnxnSocket的sendThread和sessionId</span></span><br><span class="line">    clientCnxnSocket.introduce(<span class="keyword">this</span>,sessionId);</span><br><span class="line">    <span class="comment">// 更新当前时间</span></span><br><span class="line">    clientCnxnSocket.updateNow();</span><br><span class="line">    <span class="comment">// 更新send和heard时间</span></span><br><span class="line">    clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">long</span> lastPingRwServer = Time.currentElapsedTime();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEND_PING_INTERVAL = <span class="number">10000</span>; <span class="comment">//10 seconds</span></span><br><span class="line">    InetSocketAddress serverAddress = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (state.isAlive()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果客户端还没连上</span></span><br><span class="line">            <span class="keyword">if</span> (!clientCnxnSocket.isConnected()) &#123;</span><br><span class="line">                <span class="comment">// 如果不是第一次连接，我们这里是第一次连接</span></span><br><span class="line">                <span class="keyword">if</span>(!isFirstConnect)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果客户端和服务端失联，就不要重复注册了</span></span><br><span class="line">                <span class="keyword">if</span> (closing || !state.isAlive()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置服务地址</span></span><br><span class="line">                <span class="keyword">if</span> (rwServerAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    serverAddress = rwServerAddress;</span><br><span class="line">                    rwServerAddress = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    serverAddress = hostProvider.next(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 开始连接</span></span><br><span class="line">                startConnect(serverAddress);</span><br><span class="line">                clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 网络传输发送请求</span></span><br><span class="line">            clientCnxnSocket.doTransport(to, pendingQueue, outgoingQueue, ClientCnxn.<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这个run方法我们就关心三个步骤</p>
<ul>
<li>获得服务地址:<code>serverAddress = hostProvider.next(1000);</code>,轮询使用服务地址，如果都使用过了，就休眠1000ms</li>
<li>建立tcp连接:<code>startConnect(serverAddress);</code></li>
<li>网络传输发送请求:<code>clientCnxnSocket.doTransport(to, pendingQueue, outgoingQueue, ClientCnxn.this);</code></li>
</ul>
<h2 id="获得服务地址"><a href="#获得服务地址" class="headerlink" title="获得服务地址"></a>获得服务地址</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StaticHostProvider#init()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Collection&lt;InetSocketAddress&gt; serverAddresses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (serverAddresses.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">&quot;A HostProvider may not be empty!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.serverAddresses.addAll(serverAddresses);</span><br><span class="line">    <span class="comment">// 将serverAddresses地址乱序，仅一次，以后都按照这个顺序从next()方法获得地址</span></span><br><span class="line">    Collections.shuffle(<span class="keyword">this</span>.serverAddresses);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// StaticHostProvider#next()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">next</span><span class="params">(<span class="keyword">long</span> spinDelay)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里就轮询嘛，一个地址接着一个地址</span></span><br><span class="line">    currentIndex = ++currentIndex % serverAddresses.size();</span><br><span class="line">    <span class="comment">// 循环一圈了就休眠一会儿</span></span><br><span class="line">    <span class="keyword">if</span> (currentIndex == lastIndex &amp;&amp; spinDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(spinDelay);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// We don&#x27;t want to sleep on the first ever connect attempt.</span></span><br><span class="line">        lastIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InetSocketAddress curAddr = serverAddresses.get(currentIndex);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String curHostString = getHostString(curAddr);</span><br><span class="line">        List&lt;InetAddress&gt; resolvedAddresses = <span class="keyword">new</span> ArrayList&lt;InetAddress&gt;(Arrays.asList(<span class="keyword">this</span>.resolver.getAllByName(curHostString)));</span><br><span class="line">        <span class="keyword">if</span> (resolvedAddresses.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> curAddr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果服务是以域名的形式</span></span><br><span class="line">        <span class="comment">// 且一个域名对应多个ip地址</span></span><br><span class="line">        <span class="comment">// 那就在这些ip地址中随机选一个</span></span><br><span class="line">        Collections.shuffle(resolvedAddresses);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InetSocketAddress(resolvedAddresses.get(<span class="number">0</span>), curAddr.getPort());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> curAddr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于服务器地址列表提供的比较少的场景，当<code>currentIndex == lastIndex &amp;&amp; spinDelay &gt; 0</code>时，休眠<code>spinDelay</code>毫秒。<br><code>HostProvider</code>有几点要求:</p>
<ul>
<li>next方法必须有合法的返回值，不能是null或不合法的<code>InetSocketAddress</code></li>
<li>next方法必须返回已经解析成ip地址的<code>InetSocketAddress</code>对象</li>
<li>size方法不能返回0，也就是至少要提供一个服务地址<h2 id="建立tcp连接"><a href="#建立tcp连接" class="headerlink" title="建立tcp连接"></a>建立tcp连接</h2>我们进入<code>startConnect</code>方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxn$SendThread#startConnect()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startConnect</span><span class="params">(InetSocketAddress addr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// initializing it for new connection</span></span><br><span class="line">    saslLoginFailed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 标记状态</span></span><br><span class="line">    state = States.CONNECTING;</span><br><span class="line"></span><br><span class="line">    setName(getName().replaceAll(<span class="string">&quot;\\(.*\\)&quot;</span>,</span><br><span class="line">            <span class="string">&quot;(&quot;</span> + addr.getHostName() + <span class="string">&quot;:&quot;</span> + addr.getPort() + <span class="string">&quot;)&quot;</span>));</span><br><span class="line">    ...</span><br><span class="line">    logStartConnect(addr);</span><br><span class="line">    clientCnxnSocket.connect(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里其实也没干什么，标记状态，打个日志，实际的还在<code>clientCnxnSocket.connect(addr);</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxnSocketNIO#connect()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(InetSocketAddress addr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建SocketChannel</span></span><br><span class="line">    SocketChannel sock = createSock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       registerAndConnect(sock, addr);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        LOG.error(<span class="string">&quot;Unable to open socket to &quot;</span> + addr);</span><br><span class="line">        sock.close();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    initialized = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Reset incomingBuffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lenBuffer.clear();</span><br><span class="line">    incomingBuffer = lenBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
看来重头戏实际在<code>registerAndConnect(sock, addr);</code>里，去看下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxnSocketNIO#registerAndConnect()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerAndConnect</span><span class="params">(SocketChannel sock, InetSocketAddress addr)</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    sockKey = sock.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">    <span class="keyword">boolean</span> immediateConnect = sock.connect(addr);</span><br><span class="line">    <span class="keyword">if</span> (immediateConnect) &#123;</span><br><span class="line">        sendThread.primeConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
从这里我们我能看到tcp连接连接到了服务端，然后就看看<code>sendThread.primeConnection();</code>有什么猫腻<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxn$SendThread#primeConnection()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primeConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    LOG.info(<span class="string">&quot;Socket connection established to &quot;</span></span><br><span class="line">             + clientCnxnSocket.getRemoteSocketAddress()</span><br><span class="line">             + <span class="string">&quot;, initiating session&quot;</span>);</span><br><span class="line">    isFirstConnect = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">long</span> sessId = (seenRwServerBefore) ? sessionId : <span class="number">0</span>;</span><br><span class="line">    ConnectRequest conReq = <span class="keyword">new</span> ConnectRequest(<span class="number">0</span>, lastZxid,</span><br><span class="line">            sessionTimeout, sessId, sessionPasswd);</span><br><span class="line">    <span class="keyword">synchronized</span> (outgoingQueue) &#123;</span><br><span class="line">        <span class="comment">// We add backwards since we are pushing into the front</span></span><br><span class="line">        <span class="comment">// Only send if there&#x27;s a pending watch</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> here we have the only remaining use of zooKeeper in</span></span><br><span class="line">        <span class="comment">// this class. It&#x27;s to be eliminated!</span></span><br><span class="line">        <span class="comment">// disableAutoWatchReset:客户端在会话重连接时自动复位Watcher</span></span><br><span class="line">        <span class="keyword">if</span> (!disableAutoWatchReset) &#123;</span><br><span class="line">            List&lt;String&gt; dataWatches = zooKeeper.getDataWatches();</span><br><span class="line">            List&lt;String&gt; existWatches = zooKeeper.getExistWatches();</span><br><span class="line">            List&lt;String&gt; childWatches = zooKeeper.getChildWatches();</span><br><span class="line">            <span class="keyword">if</span> (!dataWatches.isEmpty()</span><br><span class="line">                        || !existWatches.isEmpty() || !childWatches.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">                Iterator&lt;String&gt; dataWatchesIter = prependChroot(dataWatches).iterator();</span><br><span class="line">                Iterator&lt;String&gt; existWatchesIter = prependChroot(existWatches).iterator();</span><br><span class="line">                Iterator&lt;String&gt; childWatchesIter = prependChroot(childWatches).iterator();</span><br><span class="line">                <span class="keyword">long</span> setWatchesLastZxid = lastZxid;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (dataWatchesIter.hasNext()</span><br><span class="line">                               || existWatchesIter.hasNext() || childWatchesIter.hasNext()) &#123;</span><br><span class="line">                    List&lt;String&gt; dataWatchesBatch = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                    List&lt;String&gt; existWatchesBatch = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                    List&lt;String&gt; childWatchesBatch = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                    <span class="keyword">int</span> batchLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Note, we may exceed our max length by a bit when we add the last</span></span><br><span class="line">                    <span class="comment">// watch in the batch. This isn&#x27;t ideal, but it makes the code simpler.</span></span><br><span class="line">                    <span class="keyword">while</span> (batchLength &lt; SET_WATCHES_MAX_LENGTH) &#123;</span><br><span class="line">                        <span class="keyword">final</span> String watch;</span><br><span class="line">                        <span class="keyword">if</span> (dataWatchesIter.hasNext()) &#123;</span><br><span class="line">                            watch = dataWatchesIter.next();</span><br><span class="line">                            dataWatchesBatch.add(watch);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (existWatchesIter.hasNext()) &#123;</span><br><span class="line">                            watch = existWatchesIter.next();</span><br><span class="line">                            existWatchesBatch.add(watch);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childWatchesIter.hasNext()) &#123;</span><br><span class="line">                            watch = childWatchesIter.next();</span><br><span class="line">                            childWatchesBatch.add(watch);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        batchLength += watch.length();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 一波操作猛如虎，就是取出设置了watcher的节点路径，封装起来</span></span><br><span class="line">                    SetWatches sw = <span class="keyword">new</span> SetWatches(setWatchesLastZxid,</span><br><span class="line">                            dataWatchesBatch,</span><br><span class="line">                            existWatchesBatch,</span><br><span class="line">                            childWatchesBatch);</span><br><span class="line">                    <span class="comment">// 构造 注册watcher 的请求</span></span><br><span class="line">                    RequestHeader h = <span class="keyword">new</span> RequestHeader();</span><br><span class="line">                    h.setType(ZooDefs.OpCode.setWatches);</span><br><span class="line">                    h.setXid(-<span class="number">8</span>);</span><br><span class="line">                    <span class="comment">// 构造Packet</span></span><br><span class="line">                    Packet packet = <span class="keyword">new</span> Packet(h, <span class="keyword">new</span> ReplyHeader(), sw, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 放入待发送的请求队列，这里是使用LinkedList作为LIFO(先进后出)的栈</span></span><br><span class="line">                    outgoingQueue.addFirst(packet);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有权限验证数据的构造权限验证请求放到队列</span></span><br><span class="line">        <span class="keyword">for</span> (AuthData id : authInfo) &#123;</span><br><span class="line">            outgoingQueue.addFirst(<span class="keyword">new</span> Packet(<span class="keyword">new</span> RequestHeader(-<span class="number">4</span>,</span><br><span class="line">                    OpCode.auth), <span class="keyword">null</span>, <span class="keyword">new</span> AuthPacket(<span class="number">0</span>, id.scheme,</span><br><span class="line">                    id.data), <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将本次的连接请求方法栈顶，到这里outgoingQueue中就是</span></span><br><span class="line">        <span class="comment">// 1 ConnectRequest</span></span><br><span class="line">        <span class="comment">// 2 auth</span></span><br><span class="line">        <span class="comment">// 3 注册watcher 的请求</span></span><br><span class="line">        outgoingQueue.addFirst(<span class="keyword">new</span> Packet(<span class="keyword">null</span>, <span class="keyword">null</span>, conReq,</span><br><span class="line">                    <span class="keyword">null</span>, <span class="keyword">null</span>, readOnly));</span><br><span class="line">    &#125;</span><br><span class="line">    clientCnxnSocket.enableReadWriteOnly();</span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">        LOG.debug(<span class="string">&quot;Session establishment request sent on &quot;</span></span><br><span class="line">                + clientCnxnSocket.getRemoteSocketAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意:</strong> 这里加入队列使用的是<code>outgoingQueue.addFirst</code>，<code>LinkedList#addFirst</code>会将队列当做栈用，因为这里是创建会话，肯定要先连上服务端，才能验证auth信息，之后才能处理请求嘛。在普通的请求中<code>ClientCnxn#submitRequest</code>最后加入队列调用的是<code>LinkedList.add</code>方法，这个就是加入到队尾作为普通的队列使用。</p>
<p>既然加入了队列，就有地方消费，找找，还在<code>SendThread#run</code>方法中，看下<code>SendThread#run</code>方法中的<code>clientCnxnSocket.doTransport(to, pendingQueue, outgoingQueue, ClientCnxn.this);</code>方法</p>
<h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxnSocket#doTransport()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTransport</span><span class="params">(<span class="keyword">int</span> waitTimeOut, List&lt;Packet&gt; pendingQueue, LinkedList&lt;Packet&gt; outgoingQueue,  ClientCnxn cnxn)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    selector.select(waitTimeOut);</span><br><span class="line">    Set&lt;SelectionKey&gt; selected;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        selected = selector.selectedKeys();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Everything below and until we get back to the select is</span></span><br><span class="line">    <span class="comment">// non blocking, so time is effectively a constant. That is</span></span><br><span class="line">    <span class="comment">// Why we just have to do this once, here</span></span><br><span class="line">    updateNow();</span><br><span class="line">    <span class="keyword">for</span> (SelectionKey k : selected) &#123;</span><br><span class="line">        SocketChannel sc = ((SocketChannel) k.channel());</span><br><span class="line">        <span class="keyword">if</span> ((k.readyOps() &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sc.finishConnect()) &#123;</span><br><span class="line">                updateLastSendAndHeard();</span><br><span class="line">                sendThread.primeConnection();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((k.readyOps() &amp; (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != <span class="number">0</span>) &#123;</span><br><span class="line">            doIO(pendingQueue, outgoingQueue, cnxn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sendThread.getZkState().isConnected()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(outgoingQueue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (findSendablePacket(outgoingQueue,</span><br><span class="line">                    cnxn.sendThread.clientTunneledAuthenticationInProgress()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                enableWrite();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    selected.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看来干活的是<code>doIO</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxnSocketNIO#doIO()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doIO</span><span class="params">(List&lt;Packet&gt; pendingQueue, LinkedList&lt;Packet&gt; outgoingQueue, ClientCnxn cnxn)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">    SocketChannel sock = (SocketChannel) sockKey.channel();</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Socket is null!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sockKey.isReadable()) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sockKey.isWritable()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(outgoingQueue) &#123;</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            Packet p = findSendablePacket(outgoingQueue,</span><br><span class="line">                    cnxn.sendThread.clientTunneledAuthenticationInProgress());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateLastSend();</span><br><span class="line">                <span class="comment">// If we already started writing p, p.bb will already exist</span></span><br><span class="line">                <span class="comment">// 2</span></span><br><span class="line">                <span class="keyword">if</span> (p.bb == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((p.requestHeader != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                            (p.requestHeader.getType() != OpCode.ping) &amp;&amp;</span><br><span class="line">                            (p.requestHeader.getType() != OpCode.auth)) &#123;</span><br><span class="line">                        p.requestHeader.setXid(cnxn.getXid());</span><br><span class="line">                    &#125;</span><br><span class="line">                    p.createBB();</span><br><span class="line">                &#125;</span><br><span class="line">                sock.write(p.bb);</span><br><span class="line">                <span class="keyword">if</span> (!p.bb.hasRemaining()) &#123;</span><br><span class="line">                    sentCount++;</span><br><span class="line">                    <span class="comment">// 3</span></span><br><span class="line">                    outgoingQueue.removeFirstOccurrence(p);</span><br><span class="line">                    <span class="keyword">if</span> (p.requestHeader != <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; p.requestHeader.getType() != OpCode.ping</span><br><span class="line">                            &amp;&amp; p.requestHeader.getType() != OpCode.auth) &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (pendingQueue) &#123;</span><br><span class="line">                            pendingQueue.add(p);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这里是发送请求，所以看<code>sockKey.isWritable()</code>部分就可以了，这里做了三件事</p>
<ul>
<li>从队列中取出第一个<code>Packet</code></li>
<li>序列化<code>Packet</code>中的请求相关内容，写入到sock</li>
<li>将<code>Packet</code>从outgoingQueu移动到pendingQueue</li>
</ul>
<h1 id="响应处理阶段"><a href="#响应处理阶段" class="headerlink" title="响应处理阶段"></a>响应处理阶段</h1><p>请求发过去了，那么就得有响应啊，上边看的是<code>doIO</code>，有I就有O，接下来看<code>doIO</code>的read部分</p>
<h2 id="从scoket中读取response数据"><a href="#从scoket中读取response数据" class="headerlink" title="从scoket中读取response数据"></a>从scoket中读取response数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxnSocketNIO#doIO()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doIO</span><span class="params">(List&lt;Packet&gt; pendingQueue, LinkedList&lt;Packet&gt; outgoingQueue, ClientCnxn cnxn)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">    SocketChannel sock = (SocketChannel) sockKey.channel();</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Socket is null!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sockKey.isReadable()) &#123;</span><br><span class="line">        <span class="keyword">int</span> rc = sock.read(incomingBuffer);</span><br><span class="line">        <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EndOfStreamException(</span><br><span class="line">                    <span class="string">&quot;Unable to read additional data from server sessionid 0x&quot;</span></span><br><span class="line">                            + Long.toHexString(sessionId)</span><br><span class="line">                            + <span class="string">&quot;, likely server has closed socket&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!incomingBuffer.hasRemaining()) &#123;</span><br><span class="line">            incomingBuffer.flip();</span><br><span class="line">            <span class="keyword">if</span> (incomingBuffer == lenBuffer) &#123;</span><br><span class="line">                recvCount++;</span><br><span class="line">                readLength();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">                <span class="comment">// 1</span></span><br><span class="line">                readConnectResult();</span><br><span class="line">                enableRead();</span><br><span class="line">                <span class="keyword">if</span> (findSendablePacket(outgoingQueue,</span><br><span class="line">                        cnxn.sendThread.clientTunneledAuthenticationInProgress()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Since SASL authentication has completed (if client is configured to do so),</span></span><br><span class="line">                    <span class="comment">// outgoing packets waiting in the outgoingQueue can now be sent.</span></span><br><span class="line">                    enableWrite();</span><br><span class="line">                &#125;</span><br><span class="line">                lenBuffer.clear();</span><br><span class="line">                incomingBuffer = lenBuffer;</span><br><span class="line">                updateLastHeard();</span><br><span class="line">                initialized = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sendThread.readResponse(incomingBuffer);</span><br><span class="line">                lenBuffer.clear();</span><br><span class="line">                incomingBuffer = lenBuffer;</span><br><span class="line">                updateLastHeard();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sockKey.isWritable()) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理response数据"><a href="#处理response数据" class="headerlink" title="处理response数据"></a>处理response数据</h2><p>由于我们这是会话创建，所以流程会进入<code>1</code>处，进入<code>readConnectResult</code>方法看看他干了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxnSocket#readConnectResult()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readConnectResult</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ByteBufferInputStream bbis = <span class="keyword">new</span> ByteBufferInputStream(incomingBuffer);</span><br><span class="line">    BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);</span><br><span class="line">    ConnectResponse conRsp = <span class="keyword">new</span> ConnectResponse();</span><br><span class="line">    conRsp.deserialize(bbia, <span class="string">&quot;connect&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read &quot;is read-only&quot; flag</span></span><br><span class="line">    <span class="comment">// 只读模式标志</span></span><br><span class="line">    <span class="keyword">boolean</span> isRO = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        isRO = bbia.readBool(<span class="string">&quot;readOnly&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// this is ok -- just a packet from an old server which</span></span><br><span class="line">        <span class="comment">// doesn&#x27;t contain readOnly field</span></span><br><span class="line">        LOG.warn(<span class="string">&quot;Connected to an old server; r-o mode will be unavailable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.sessionId = conRsp.getSessionId();</span><br><span class="line">    sendThread.onConnected(conRsp.getTimeOut(), <span class="keyword">this</span>.sessionId,</span><br><span class="line">            conRsp.getPasswd(), isRO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是把<code>ConnectResponse</code>反序列化出来，然后交由<code>sendThread</code>去处理连接的相关事宜</p>
<h2 id="连接成功"><a href="#连接成功" class="headerlink" title="连接成功"></a>连接成功</h2><p>看下<code>sendThread.onConnected</code>方法，看这个方法名，好像在监听连接事件诶</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxn$SendThread#onConnected()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onConnected</span><span class="params">(<span class="keyword">int</span> _negotiatedSessionTimeout, <span class="keyword">long</span> _sessionId,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">byte</span>[] _sessionPasswd, <span class="keyword">boolean</span> isRO)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    negotiatedSessionTimeout = _negotiatedSessionTimeout;</span><br><span class="line">    ...</span><br><span class="line">    readTimeout = negotiatedSessionTimeout * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">    connectTimeout = negotiatedSessionTimeout / hostProvider.size();</span><br><span class="line">    hostProvider.onConnected();</span><br><span class="line">    sessionId = _sessionId;</span><br><span class="line">    sessionPasswd = _sessionPasswd;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    state = (isRO) ?</span><br><span class="line">            States.CONNECTEDREADONLY : States.CONNECTED;</span><br><span class="line">    seenRwServerBefore |= !isRO;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    KeeperState eventState = (isRO) ?</span><br><span class="line">            KeeperState.ConnectedReadOnly : KeeperState.SyncConnected;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    eventThread.queueEvent(<span class="keyword">new</span> WatchedEvent(</span><br><span class="line">            Watcher.Event.EventType.None,</span><br><span class="line">            eventState, <span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能到达<code>1</code>处说明已经正常连上了，剩下的步骤作用如下</p>
<ul>
<li>设置zookeeper客户端的状态，是只读连接，还是普通连接</li>
<li>设置<code>Watcher</code>中的事件状态</li>
<li>事件处理线程处理事件:<code>Watcher.Event.EventType</code>包含<code>None (-1)</code>,<code>NodeCreated (1)</code>,<code>NodeDeleted (2)</code>,<code>NodeDataChanged (3)</code>,<code>NodeChildrenChanged (4)</code>几种事件，因为我们这里是会话连接，所以使用<code>None</code>事件</li>
</ul>
<h2 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h2><p>进入<code>eventThread.queueEvent</code>方法看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxn$EventThread#queueEvent()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queueEvent</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.getType() == EventType.None</span><br><span class="line">            &amp;&amp; sessionState == event.getState()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sessionState = event.getState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// materialize the watchers based on the event</span></span><br><span class="line">    WatcherSetEventPair pair = <span class="keyword">new</span> WatcherSetEventPair(</span><br><span class="line">            watcher.materialize(event.getState(), event.getType(),</span><br><span class="line">                    event.getPath()),</span><br><span class="line">                    event);</span><br><span class="line">    <span class="comment">// queue the pair (watch set &amp; event) for later processing</span></span><br><span class="line">    waitingEvents.add(pair);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码在之前<code>Watcher</code>机制那篇中看过，就是根据state，type，path查出对应的<code>Watcher</code>放到<code>waitingEvents</code>这个待处理的事件队列中等待处理，然后也跟之前一样，在<code>ClientCnxn$EventThread#run()</code>方法中处理真正的业务逻辑。</p>
<p>以上就是一次会话创建的完整过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/08/27/zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%80%E6%AC%A1%E4%BC%9A%E8%AF%9D%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/" data-id="ckjr4ve0u0091f0ukhtyead3o" data-title="zookeeper客户端一次会话的创建过程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/" rel="tag">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-zookeeper权限控制机制ACL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/08/26/zookeeper%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6ACL/" class="article-date">
  <time class="dt-published" datetime="2018-08-26T13:26:52.000Z" itemprop="datePublished">2018-08-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/zookeeper/">zookeeper</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/08/26/zookeeper%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6ACL/">zookeeper权限控制机制ACL</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>ACL:Access Controll List，访问控制列表，可以针对任意用户和组进行细粒度的权限控制</p>
<h1 id="权限模式-Scheme"><a href="#权限模式-Scheme" class="headerlink" title="权限模式:Scheme"></a>权限模式:Scheme</h1><p>权限模式是用来确定权限验证过程中使用的检验策略，zookeeper中有如下几种模式</p>
<ul>
<li>IP:通过指定ip地址来进行权限控制，也可以通过网段来进行权限配置，比如<code>192.168.0.1/24</code></li>
<li>Digest:这是最常用的权限控制模式，通过用户名密码的方式认证，不过要对<code>idPassword</code>进行两次加密形如<code>BASE64(SHA1(idPassword))</code>，算法如下:
        
          <p class="article-more-link">
            <a href="/2018/08/26/zookeeper%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6ACL/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/08/26/zookeeper%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6ACL/" data-id="ckjr4vdzg002wf0uk4dyi47z7" data-title="zookeeper权限控制机制ACL" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/" rel="tag">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-zookeeper通信包proto中的数据结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/08/26/zookeeper%E9%80%9A%E4%BF%A1%E5%8C%85proto%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2018-08-26T08:21:02.000Z" itemprop="datePublished">2018-08-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/zookeeper/">zookeeper</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/08/26/zookeeper%E9%80%9A%E4%BF%A1%E5%8C%85proto%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">zookeeper通信包proto中的数据结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>看下主要的文件</p>
        
          <p class="article-more-link">
            <a href="/2018/08/26/zookeeper%E9%80%9A%E4%BF%A1%E5%8C%85proto%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/08/26/zookeeper%E9%80%9A%E4%BF%A1%E5%8C%85proto%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="ckjr4vdzm003ff0uk4pr13jr3" data-title="zookeeper通信包proto中的数据结构" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/" rel="tag">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-zookeeper通知机制扫盲" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/08/23/zookeeper%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E6%89%AB%E7%9B%B2/" class="article-date">
  <time class="dt-published" datetime="2018-08-23T12:55:04.000Z" itemprop="datePublished">2018-08-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/zookeeper/">zookeeper</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/08/23/zookeeper%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E6%89%AB%E7%9B%B2/">zookeeper通知机制扫盲</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>zookeeper引入了<code>Watcher</code>机制来实现分布式的通知功能，zookeeper允许客户端向服务端注册一个<code>Watcher</code>监听，当服务端的某些指定事件触发这个<code>Watcher</code>，那么就会向指定客户端发送事件来实现分布式的通知功能。<br><code>Watcher</code>机制的流程如下图:</p>
<p><img src="http://file.ornobug.top/zookeeper_watcher%E6%9C%BA%E5%88%B6.png" alt="zookeeper_watcher流程" title="zookeeper_watcher流程"></p>
<p><code>Watcher</code>机制中包括<strong>客户端线程</strong>、<strong>客户端WatcherManager</strong>、<strong>服务端</strong>三部分，流程是客户端向服务端注册<code>Watcher</code>的同时也会将该watcher存储在本地的watcherManager，当服务端触发<code>Watcher</code>事件之后会向客户端发送通知，客户端从watcherManager中取出watcher对象来执行回调。</p>
<h1 id="Watcher数据模型"><a href="#Watcher数据模型" class="headerlink" title="Watcher数据模型"></a>Watcher数据模型</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This interface defines the possible states an Event may represent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@InterfaceAudience</span>.Public</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Enumeration of states the ZooKeeper may be at the event</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@InterfaceAudience</span>.Public</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">KeeperState</span> </span>&#123;</span><br><span class="line">            <span class="comment">/** Unused, this state is never generated by the server */</span></span><br><span class="line">            <span class="meta">@Deprecated</span></span><br><span class="line">            Unknown (-<span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">            <span class="comment">/** The client is in the disconnected state - it is not connected</span></span><br><span class="line"><span class="comment">             * to any server in the ensemble. */</span></span><br><span class="line">            Disconnected (<span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">            <span class="comment">/** Unused, this state is never generated by the server */</span></span><br><span class="line">            <span class="meta">@Deprecated</span></span><br><span class="line">            NoSyncConnected (<span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">            <span class="comment">/** The client is in the connected state - it is connected</span></span><br><span class="line"><span class="comment">             * to a server in the ensemble (one of the servers specified</span></span><br><span class="line"><span class="comment">             * in the host connection parameter during ZooKeeper client</span></span><br><span class="line"><span class="comment">             * creation). */</span></span><br><span class="line">            SyncConnected (<span class="number">3</span>),</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Auth failed state</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            AuthFailed (<span class="number">4</span>),</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * The client is connected to a read-only server, that is the</span></span><br><span class="line"><span class="comment">             * server which is not currently connected to the majority.</span></span><br><span class="line"><span class="comment">             * The only operations allowed after receiving this state is</span></span><br><span class="line"><span class="comment">             * read operations.</span></span><br><span class="line"><span class="comment">             * This state is generated for read-only clients only since</span></span><br><span class="line"><span class="comment">             * read/write clients aren&#x27;t allowed to connect to r/o servers.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ConnectedReadOnly (<span class="number">5</span>),</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">              * SaslAuthenticated: used to notify clients that they are SASL-authenticated,</span></span><br><span class="line"><span class="comment">              * so that they can perform Zookeeper actions with their SASL-authorized permissions.</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">            SaslAuthenticated(<span class="number">6</span>),</span><br><span class="line"></span><br><span class="line">            <span class="comment">/** The serving cluster has expired this session. The ZooKeeper</span></span><br><span class="line"><span class="comment">             * client connection (the session) is no longer valid. You must</span></span><br><span class="line"><span class="comment">             * create a new client connection (instantiate a new ZooKeeper</span></span><br><span class="line"><span class="comment">             * instance) if you with to access the ensemble. */</span></span><br><span class="line">            Expired (-<span class="number">112</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> intValue;     <span class="comment">// Integer representation of value</span></span><br><span class="line">                                            <span class="comment">// for sending over wire</span></span><br><span class="line"></span><br><span class="line">            KeeperState(<span class="keyword">int</span> intValue) &#123;</span><br><span class="line">                <span class="keyword">this</span>.intValue = intValue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> intValue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeeperState <span class="title">fromInt</span><span class="params">(<span class="keyword">int</span> intValue)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span>(intValue) &#123;</span><br><span class="line">                    <span class="keyword">case</span>   -<span class="number">1</span>: <span class="keyword">return</span> KeeperState.Unknown;</span><br><span class="line">                    <span class="keyword">case</span>    <span class="number">0</span>: <span class="keyword">return</span> KeeperState.Disconnected;</span><br><span class="line">                    <span class="keyword">case</span>    <span class="number">1</span>: <span class="keyword">return</span> KeeperState.NoSyncConnected;</span><br><span class="line">                    <span class="keyword">case</span>    <span class="number">3</span>: <span class="keyword">return</span> KeeperState.SyncConnected;</span><br><span class="line">                    <span class="keyword">case</span>    <span class="number">4</span>: <span class="keyword">return</span> KeeperState.AuthFailed;</span><br><span class="line">                    <span class="keyword">case</span>    <span class="number">5</span>: <span class="keyword">return</span> KeeperState.ConnectedReadOnly;</span><br><span class="line">                    <span class="keyword">case</span>    <span class="number">6</span>: <span class="keyword">return</span> KeeperState.SaslAuthenticated;</span><br><span class="line">                    <span class="keyword">case</span> -<span class="number">112</span>: <span class="keyword">return</span> KeeperState.Expired;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Invalid integer value for conversion to KeeperState&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Enumeration of types of events that may occur on the ZooKeeper</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@InterfaceAudience</span>.Public</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EventType</span> </span>&#123;</span><br><span class="line">            None (-<span class="number">1</span>),</span><br><span class="line">            NodeCreated (<span class="number">1</span>),</span><br><span class="line">            NodeDeleted (<span class="number">2</span>),</span><br><span class="line">            NodeDataChanged (<span class="number">3</span>),</span><br><span class="line">            NodeChildrenChanged (<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> intValue;     <span class="comment">// Integer representation of value</span></span><br><span class="line">                                            <span class="comment">// for sending over wire</span></span><br><span class="line"></span><br><span class="line">            EventType(<span class="keyword">int</span> intValue) &#123;</span><br><span class="line">                <span class="keyword">this</span>.intValue = intValue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> intValue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventType <span class="title">fromInt</span><span class="params">(<span class="keyword">int</span> intValue)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span>(intValue) &#123;</span><br><span class="line">                    <span class="keyword">case</span> -<span class="number">1</span>: <span class="keyword">return</span> EventType.None;</span><br><span class="line">                    <span class="keyword">case</span>  <span class="number">1</span>: <span class="keyword">return</span> EventType.NodeCreated;</span><br><span class="line">                    <span class="keyword">case</span>  <span class="number">2</span>: <span class="keyword">return</span> EventType.NodeDeleted;</span><br><span class="line">                    <span class="keyword">case</span>  <span class="number">3</span>: <span class="keyword">return</span> EventType.NodeDataChanged;</span><br><span class="line">                    <span class="keyword">case</span>  <span class="number">4</span>: <span class="keyword">return</span> EventType.NodeChildrenChanged;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Invalid integer value for conversion to EventType&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="状态与事件"><a href="#状态与事件" class="headerlink" title="状态与事件"></a>状态与事件</h2><p>zookeeper的状态与能响应的事件类型如下:</p>
<table><tr align="center"><td>KeeperState</td><td>EventType</td><td>触发条件</td><td>说明</td></tr><tr align="center"><td rowspan="5">SyncConnected (3), ConnectedReadOnly (5),SaslAuthenticated(6)</td><td >None(-1)</td><td >客户端与服务端成功建立会话</td><td rowspan="5">SyncConnected 表示客户端与服务端保持连接；ConnectedReadOnly 表示连接的zookeeper机器在丢失leader之后提供读服务状态；SaslAuthenticated表示当前连接使用Sasl的权限连接</td></tr><tr align="center"><td >NodeCreated (1)</td><td >Watcher监听的数据节点被创建</td></tr><tr align="center"><td >NodeDeleted (2)</td><td >Watcher监听的数据节点被删除</td></tr><tr align="center"><td >NodeDataChanged (3)</td> <td >Watcher监听的数据节点的数据内容发生变更，即使改了几次最后结果跟之前一样仍旧会触发事件，每改一次都会触发</td></tr><tr align="center"><td >NodeChildrenChanged (4)</td><td >Watcher监听的数据节点的子列表发生变化，包括子列表数量和组成，不是数据</td></tr><tr align="center"><td >Disconnected (0)</td><td >None(-1)</td><td >客户端与服务端断开连接</td><td >当前状态表示客户端与服务端处于失联状态</td></tr><tr align="center"><td >Expired (-112)</td><td >None(-1)</td><td >会话超时</td><td >当前状态表示客户端会话失效，会收到SessionExiredException</td></tr><tr align="center"><td >Expired (-112)</td><td >None(-1)</td><td >会话超时</td><td >当前状态表示客户端会话失效，会收到SessionExiredException</td></tr><tr align="center"><td >AuthFailed (4)</td><td >None(-1)</td><td >权限错误：使用错误的scheme进行权限检查；SASL权限检查失败</td><td >会收到AuthFailedException</td></tr></table>
## 回调方法process
在服务端触发事件后会向客户端发送通知，客户端会回调方法，回调方法定义如下：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span></span>;</span><br></pre></td></tr></table></figure>
看下`WatchedEvent `数据结构
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchedEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> KeeperState keeperState;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> EventType eventType;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Convert a WatcherEvent sent over the wire into a full-fledged WatcherEvent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// WatcherEvent -&gt; WatchedEvent</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WatchedEvent</span><span class="params">(WatcherEvent eventMessage)</span> </span>&#123;</span><br><span class="line">        keeperState = KeeperState.fromInt(eventMessage.getState());</span><br><span class="line">        eventType = EventType.fromInt(eventMessage.getType());</span><br><span class="line">        path = eventMessage.getPath();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Convert WatchedEvent to type that can be sent over network</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// WatchedEvent -&gt; WatcherEvent</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WatcherEvent <span class="title">getWrapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WatcherEvent(eventType.getIntValue(),</span><br><span class="line">                                keeperState.getIntValue(),</span><br><span class="line">                                path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可见`WatchedEvent`封装了一个**节点路径**上的**连接状态**和对应的**能响应的事件**，这样能方便回调方法对事件的处理。其中还有个`getWrapper`方法，他返回`WatcherEvent`。
`WatcherEvent`数据结构如下
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatcherEvent</span> <span class="keyword">implements</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line">		<span class="keyword">private</span> String path;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(OutputArchive a_, String tag)</span> <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">				...</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deserialize</span><span class="params">(InputArchive a_, String tag)</span> <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">			    ...</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
`WatcherEvent`其实是对`WatchedEvent`的简单封装，然后实现`Record`接口用于客户端和服务端之间网络传输。
那么数据传输的流程就出来了:服务端生成`WatchedEvent`事件后会通过`getWrapper`方法把自己封装成`WatcherEvent`，通过网络传输到达客户端，通过`WatchedEvent`的构造函数将`WatcherEvent`转回`WatchedEvent`。从这里可以看出，在事件传递的过程中并没有传递节点相关数据，所以这也就导致**客户端在执行回调方法要自行获取服务器上的新的节点数据**，这是`Watcher`机制的一大特点。

<h1 id="Watcher工作机制"><a href="#Watcher工作机制" class="headerlink" title="Watcher工作机制"></a>Watcher工作机制</h1><h2 id="客户端注册Watcher"><a href="#客户端注册Watcher" class="headerlink" title="客户端注册Watcher"></a>客户端注册Watcher</h2><p>Zookeeper客户端初始化构造时会向构造函数中传入Watcher</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZOOKEEPER_CLIENT_CNXN_SOCKET = <span class="string">&quot;zookeeper.clientCnxnSocket&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ClientCnxn cnxn;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//Keep these two lines together to keep the initialization order explicit</span></span><br><span class="line">        LOG = LoggerFactory.getLogger(ZooKeeper.class);</span><br><span class="line">        Environment.logEnv(<span class="string">&quot;Client environment:&quot;</span>, LOG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZooKeeperSaslClient <span class="title">getSaslClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnxn.zooKeeperSaslClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ZKWatchManager watchManager = <span class="keyword">new</span> ZKWatchManager();</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">getDataWatches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(watchManager.dataWatches) &#123;</span><br><span class="line">            List&lt;String&gt; rc = <span class="keyword">new</span> ArrayList&lt;String&gt;(watchManager.dataWatches.keySet());</span><br><span class="line">            <span class="keyword">return</span> rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">getExistWatches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(watchManager.existWatches) &#123;</span><br><span class="line">            List&lt;String&gt; rc =  <span class="keyword">new</span> ArrayList&lt;String&gt;(watchManager.existWatches.keySet());</span><br><span class="line">            <span class="keyword">return</span> rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">getChildWatches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(watchManager.childWatches) &#123;</span><br><span class="line">            List&lt;String&gt; rc = <span class="keyword">new</span> ArrayList&lt;String&gt;(watchManager.childWatches.keySet());</span><br><span class="line">            <span class="keyword">return</span> rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的watcher参数就是客户端向服务端注册的watcher</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(connectString, sessionTimeout, watcher, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">boolean</span> canBeReadOnly)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;Initiating client connection, connectString=&quot;</span> + connectString</span><br><span class="line">                + <span class="string">&quot; sessionTimeout=&quot;</span> + sessionTimeout + <span class="string">&quot; watcher=&quot;</span> + watcher);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将watcher存储在客户端的watchManager上</span></span><br><span class="line">        watchManager.defaultWatcher = watcher;</span><br><span class="line"></span><br><span class="line">        ConnectStringParser connectStringParser = <span class="keyword">new</span> ConnectStringParser(</span><br><span class="line">                connectString);</span><br><span class="line">        HostProvider hostProvider = <span class="keyword">new</span> StaticHostProvider(</span><br><span class="line">                connectStringParser.getServerAddresses());</span><br><span class="line">        cnxn = <span class="keyword">new</span> ClientCnxn(connectStringParser.getChrootPath(),</span><br><span class="line">                hostProvider, sessionTimeout, <span class="keyword">this</span>, watchManager,</span><br><span class="line">                getClientCnxnSocket(), canBeReadOnly);</span><br><span class="line">        cnxn.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个watcher对象会作为当前会话整个生命周期的默认<code>Watcher</code>，会被一直保存在客户端的<code>ZKWatchManager</code>的<code>defaultWatcher</code>中。另外能注册<code>Watcher</code>的是<code>getData</code>，<code>getChildren</code>，<code>exist</code>三个方法。以<code>getData</code>为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getData(<span class="keyword">final</span> String path, Watcher watcher, Stat stat)</span><br><span class="line">        <span class="keyword">throws</span> KeeperException, InterruptedException</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">final</span> String clientPath = path;</span><br><span class="line">        PathUtils.validatePath(clientPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the watch contains the un-chroot path</span></span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        WatchRegistration wcb = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (watcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wcb = <span class="keyword">new</span> DataWatchRegistration(watcher, clientPath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String serverPath = prependChroot(clientPath);</span><br><span class="line"></span><br><span class="line">        RequestHeader h = <span class="keyword">new</span> RequestHeader();</span><br><span class="line">        h.setType(ZooDefs.OpCode.getData);</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        GetDataRequest request = <span class="keyword">new</span> GetDataRequest();</span><br><span class="line">        request.setPath(serverPath);</span><br><span class="line">        request.setWatch(watcher != <span class="keyword">null</span>);</span><br><span class="line">        GetDataResponse response = <span class="keyword">new</span> GetDataResponse();</span><br><span class="line">        ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);</span><br><span class="line">        <span class="keyword">if</span> (r.getErr() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> KeeperException.create(KeeperException.Code.get(r.getErr()),</span><br><span class="line">                    clientPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">            DataTree.copyStat(response.getStat(), stat);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response.getData();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ClientCnxn#submitRequest</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReplyHeader <span class="title">submitRequest</span><span class="params">(RequestHeader h, Record request,</span></span></span><br><span class="line"><span class="function"><span class="params">            Record response, WatchRegistration watchRegistration)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ReplyHeader r = <span class="keyword">new</span> ReplyHeader();</span><br><span class="line">        Packet packet = queuePacket(h, r, request, response, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,<span class="keyword">null</span>, watchRegistration);</span><br><span class="line">        <span class="keyword">synchronized</span> (packet) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!packet.finished) &#123;</span><br><span class="line">                packet.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ClientCnxn#queuePacket</span></span><br><span class="line"><span class="function">Packet <span class="title">queuePacket</span><span class="params">(RequestHeader h, ReplyHeader r, Record request,</span></span></span><br><span class="line"><span class="function"><span class="params">            Record response, AsyncCallback cb, String clientPath,</span></span></span><br><span class="line"><span class="function"><span class="params">            String serverPath, Object ctx, WatchRegistration watchRegistration)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Packet packet = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that we do not generate the Xid for the packet yet. It is</span></span><br><span class="line">        <span class="comment">// generated later at send-time, by an implementation of ClientCnxnSocket::doIO(),</span></span><br><span class="line">        <span class="comment">// where the packet is actually sent.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (outgoingQueue) &#123;</span><br><span class="line">		    <span class="comment">// 封装对象</span></span><br><span class="line">            packet = <span class="keyword">new</span> Packet(h, r, request, response, watchRegistration);</span><br><span class="line">            packet.cb = cb;</span><br><span class="line">            packet.ctx = ctx;</span><br><span class="line">            packet.clientPath = clientPath;</span><br><span class="line">            packet.serverPath = serverPath;</span><br><span class="line">            <span class="keyword">if</span> (!state.isAlive() || closing) &#123;</span><br><span class="line">                conLossPacket(packet);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// If the client is asking to close the session then</span></span><br><span class="line">                <span class="comment">// mark as closing</span></span><br><span class="line">                <span class="keyword">if</span> (h.getType() == OpCode.closeSession) &#123;</span><br><span class="line">                    closing = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 加入发送队列</span></span><br><span class="line">                outgoingQueue.add(packet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒selector</span></span><br><span class="line">        sendThread.getClientCnxnSocket().wakeupCnxn();</span><br><span class="line">        <span class="keyword">return</span> packet;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>主要看两件事:</p>
<ul>
<li>将路径和<code>Watcher</code>的对应关系封装到<code>WatchRegistration</code>中</li>
<li>标记当前request是否使用<code>Watcher</code>监听</li>
</ul>
<p>在<code>ClientCnxn#submitRequest</code>中一些信息被封装到<code>Packet</code>中，<code>Packet</code>是zookeeper中最小的通信协议单元，用于客户端和服务端的网络传输，任何需要传输的对象都会被封装到其中。<code>ClientCnxn#queuePacket</code>用途是封装对象，并加入到发送队列然后唤醒selector等待nio的Socket发送<code>LinkedList&lt;Packet&gt;</code>中的数据，然后通过<code>ClientCnxnSocketNIO#doIO</code>中的<code>sendThread.readResponse(incomingBuffer)</code>获得返回值。<br>看下<code>ClientCncx$SendThread#readResponse</code>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCncx$SendThread#readResponse</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readResponse</span><span class="params">(ByteBuffer incomingBuffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// -1代表事件通知</span></span><br><span class="line">    <span class="keyword">if</span> (replyHdr.getXid() == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// -1 means notification</span></span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">            LOG.debug(<span class="string">&quot;Got notification sessionid:0x&quot;</span></span><br><span class="line">                + Long.toHexString(sessionId));</span><br><span class="line">        &#125;</span><br><span class="line">        WatcherEvent event = <span class="keyword">new</span> WatcherEvent();</span><br><span class="line">        event.deserialize(bbia, <span class="string">&quot;response&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// convert from a server path to a client path</span></span><br><span class="line">        <span class="keyword">if</span> (chrootPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String serverPath = event.getPath();</span><br><span class="line">            <span class="keyword">if</span>(serverPath.compareTo(chrootPath)==<span class="number">0</span>)</span><br><span class="line">                event.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (serverPath.length() &gt; chrootPath.length())</span><br><span class="line">                event.setPath(serverPath.substring(chrootPath.length()));</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            	LOG.warn(<span class="string">&quot;Got server path &quot;</span> + event.getPath()</span><br><span class="line">            			+ <span class="string">&quot; which is too short for chroot path &quot;</span></span><br><span class="line">            			+ chrootPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WatchedEvent we = <span class="keyword">new</span> WatchedEvent(event);</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">            LOG.debug(<span class="string">&quot;Got &quot;</span> + we + <span class="string">&quot; for sessionid 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(sessionId));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eventThread.queueEvent( we );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        finishPacket(packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ClientCncx#finishPacket</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishPacket</span><span class="params">(Packet p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p.watchRegistration != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.watchRegistration.register(p.replyHeader.getErr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.cb == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">            p.finished = <span class="keyword">true</span>;</span><br><span class="line">            p.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p.finished = <span class="keyword">true</span>;</span><br><span class="line">        eventThread.queuePacket(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>finishPacket</code>会从<code>Packet</code>中取出<code>WatchRegistration</code>，将<code>WatchRegistration</code>管理的当前地址的<code>Watcher</code>注册到<code>WatcherManager</code>管理的<code>*Watches</code>中，具体注册步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Zookeeper#register</span></span><br><span class="line"><span class="comment">// rc：0代表没有异常，非0代表出现了一场</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">int</span> rc)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (shouldAddWatch(rc)) &#123;</span><br><span class="line">		<span class="comment">// ZKWatchManager#Map&lt;String, Set&lt;Watcher&gt;&gt; dataWatches</span></span><br><span class="line">        Map&lt;String, Set&lt;Watcher&gt;&gt; watches = getWatches(rc);</span><br><span class="line">        <span class="keyword">synchronized</span>(watches) &#123;</span><br><span class="line">            Set&lt;Watcher&gt; watchers = watches.get(clientPath);</span><br><span class="line">            <span class="keyword">if</span> (watchers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                watchers = <span class="keyword">new</span> HashSet&lt;Watcher&gt;();</span><br><span class="line">                watches.put(clientPath, watchers);</span><br><span class="line">            &#125;</span><br><span class="line">            watchers.add(watcher);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Zookeeper$DataWatchRegistration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataWatchRegistration</span> <span class="keyword">extends</span> <span class="title">WatchRegistration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataWatchRegistration</span><span class="params">(Watcher watcher, String clientPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(watcher, clientPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;String, Set&lt;Watcher&gt;&gt; getWatches(<span class="keyword">int</span> rc) &#123;</span><br><span class="line">        <span class="keyword">return</span> watchManager.dataWatches;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>register</code>方法在没有异常的情况下会取出<code>watcherManager</code>所管理的<code>dataWatches</code>，然后将<code>WatchRegistration</code>持有的<code>Watcher</code>放入到<code>watcherManager.dataWatches</code>中进行管理，其结构是如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatchManager</span> <span class="keyword">implements</span> <span class="title">ClientWatchManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">// getData方法时注册的watcher</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; dataWatches =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</span><br><span class="line">    <span class="comment">// exists方法时注册的watcher</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; existWatches =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</span><br><span class="line">   <span class="comment">// getChildren方法时注册的watcher</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; childWatches =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Watcher defaultWatcher;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，客户端注册<code>Watcher</code>的流程图如下</p>
<p><img src="http://file.ornobug.top/zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AFwatcher%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.png" alt="zookeeper客户端watcher注册流程" title="zookeeper客户端watcher注册流程"></p>
<p>每次调用<code>getData</code>都要注册<code>Watcher</code>，这会导致服务端内存爆炸，所以<code>Packet</code>在序列化的时候就不会序列化<code>watchRegistration</code>了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxn</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Packet</span> </span>&#123;</span><br><span class="line">	RequestHeader requestHeader;</span><br><span class="line"></span><br><span class="line">	ReplyHeader replyHeader;</span><br><span class="line"></span><br><span class="line">	Record request;</span><br><span class="line"></span><br><span class="line">	Record response;</span><br><span class="line"></span><br><span class="line">	ByteBuffer bb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Client&#x27;s view of the path (may differ due to chroot) **/</span></span><br><span class="line">	String clientPath;</span><br><span class="line">	<span class="comment">/** Servers&#x27;s view of the path (may differ due to chroot) **/</span></span><br><span class="line">	String serverPath;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">boolean</span> finished;</span><br><span class="line"></span><br><span class="line">	AsyncCallback cb;</span><br><span class="line"></span><br><span class="line">	Object ctx;</span><br><span class="line"></span><br><span class="line">	WatchRegistration watchRegistration;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> readOnly;</span><br><span class="line"></span><br><span class="line">	Packet(RequestHeader requestHeader, ReplyHeader replyHeader,</span><br><span class="line">	       Record request, Record response,</span><br><span class="line">	       WatchRegistration watchRegistration, <span class="keyword">boolean</span> readOnly) &#123;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">this</span>.requestHeader = requestHeader;</span><br><span class="line">	    <span class="keyword">this</span>.replyHeader = replyHeader;</span><br><span class="line">	    <span class="keyword">this</span>.request = request;</span><br><span class="line">	    <span class="keyword">this</span>.response = response;</span><br><span class="line">	    <span class="keyword">this</span>.readOnly = readOnly;</span><br><span class="line">	    <span class="keyword">this</span>.watchRegistration = watchRegistration;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">	        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">	        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);</span><br><span class="line">	        boa.writeInt(-<span class="number">1</span>, <span class="string">&quot;len&quot;</span>); <span class="comment">// We&#x27;ll fill this in later</span></span><br><span class="line">	        <span class="keyword">if</span> (requestHeader != <span class="keyword">null</span>) &#123;</span><br><span class="line">		        <span class="comment">// 这里序列化requestHeader</span></span><br><span class="line">	            requestHeader.serialize(boa, <span class="string">&quot;header&quot;</span>);</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ConnectRequest) &#123;</span><br><span class="line">		        <span class="comment">// 这里序列化request</span></span><br><span class="line">	            request.serialize(boa, <span class="string">&quot;connect&quot;</span>);</span><br><span class="line">	            <span class="comment">// append &quot;am-I-allowed-to-be-readonly&quot; flag</span></span><br><span class="line">	            boa.writeBool(readOnly, <span class="string">&quot;readOnly&quot;</span>);</span><br><span class="line">	        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">	            request.serialize(boa, <span class="string">&quot;request&quot;</span>);</span><br><span class="line">	        &#125;</span><br><span class="line">	        baos.close();</span><br><span class="line">	        <span class="keyword">this</span>.bb = ByteBuffer.wrap(baos.toByteArray());</span><br><span class="line">	        <span class="keyword">this</span>.bb.putInt(<span class="keyword">this</span>.bb.capacity() - <span class="number">4</span>);</span><br><span class="line">	        <span class="keyword">this</span>.bb.rewind();</span><br><span class="line">	    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	        LOG.warn(<span class="string">&quot;Ignoring unexpected exception&quot;</span>, e);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>createBB</code>方法只序列化了<code>requestHeader</code>和<code>request</code></p>
<h2 id="服务端处理Watcher"><a href="#服务端处理Watcher" class="headerlink" title="服务端处理Watcher"></a>服务端处理Watcher</h2><p>既然<code>Packet</code>序列化时没有传递<code>Watcher</code>，那么服务端如何完成客户端的<code>Watcher</code>注册?如何处理特定的<code>Watcher</code>呢？</p>
<h3 id="ServerCnxn存储"><a href="#ServerCnxn存储" class="headerlink" title="ServerCnxn存储"></a>ServerCnxn存储</h3><p><img src="http://file.ornobug.top/zookeeper%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A5%E6%94%B6watcher%E6%B5%81%E7%A8%8B.jpg" alt="zookeeper服务端接收watcher流程" title="zookeeper服务端接收watcher流程"><br>来看下Zookeeper服务端的请求处理器<code>FinalRequestProcessor</code>，这是请求处理器链中最后一个处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalRequestProcessor</span> <span class="keyword">implements</span> <span class="title">RequestProcessor</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">case</span> OpCode.getData: &#123;</span><br><span class="line">                lastOp = <span class="string">&quot;GETD&quot;</span>;</span><br><span class="line">                GetDataRequest getDataRequest = <span class="keyword">new</span> GetDataRequest();</span><br><span class="line">                ByteBufferInputStream.byteBuffer2Record(request.request,</span><br><span class="line">                        getDataRequest);</span><br><span class="line">                DataNode n = zks.getZKDatabase().getNode(getDataRequest.getPath());</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException();</span><br><span class="line">                &#125;</span><br><span class="line">                PrepRequestProcessor.checkACL(zks, zks.getZKDatabase().aclForNode(n),</span><br><span class="line">                        ZooDefs.Perms.READ,</span><br><span class="line">                        request.authInfo);</span><br><span class="line">                Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">                <span class="comment">// 这里</span></span><br><span class="line">                <span class="keyword">byte</span> b[] = zks.getZKDatabase().getData(getDataRequest.getPath(), stat,</span><br><span class="line">                        getDataRequest.getWatch() ? cnxn : <span class="keyword">null</span>);</span><br><span class="line">                rsp = <span class="keyword">new</span> GetDataResponse(b, stat);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到了<code>getDataRequest.getWatch() ? cnxn : null</code>，记得在客户端封装request的时候会设置是否有<code>Watcher</code>监听，这里就派上用场了。cnxn 是<code>ServerCnxn</code>的实例,<code>ServerCnxn</code>代表一条客户端和服务端的连接，可以理解为上下文。具体实现类有两个<code>NettyServerCnxn(3.4.0以后)</code>、<code>NIOServerCnxn</code>，以<code>NettyServerCnxn</code>为例，可以把它看做<code>Watcher</code></p>
<p><img src="http://file.ornobug.top/NettyServerCnxn%E7%B1%BB%E5%9B%BE.png" alt="NettyServerCnxn类图" title="NettyServerCnxn类图"></p>
<p>看下<code>getData方法</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataTree</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getData(String path, Stat stat, Watcher watcher)</span><br><span class="line">    <span class="keyword">throws</span> KeeperException.NoNodeException &#123;</span><br><span class="line">    DataNode n = nodes.get(path);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (n) &#123;</span><br><span class="line">        n.copyStat(stat);</span><br><span class="line">        <span class="keyword">if</span> (watcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dataWatches.addWatch(path, watcher);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WatchManager</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, HashSet&lt;Watcher&gt;&gt; watchTable = <span class="keyword">new</span> HashMap&lt;String, HashSet&lt;Watcher&gt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Watcher, HashSet&lt;String&gt;&gt; watch2Paths = <span class="keyword">new</span> HashMap&lt;Watcher, HashSet&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addWatch</span><span class="params">(String path, Watcher watcher)</span> </span>&#123;</span><br><span class="line">	HashSet&lt;Watcher&gt; list = watchTable.get(path);</span><br><span class="line">    <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t waste memory if there are few watches on a node</span></span><br><span class="line">        <span class="comment">// rehash when the 4th entry is added, doubling size thereafter</span></span><br><span class="line">        <span class="comment">// seems like a good compromise</span></span><br><span class="line">        list = <span class="keyword">new</span> HashSet&lt;Watcher&gt;(<span class="number">4</span>);</span><br><span class="line">        watchTable.put(path, list);</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(watcher);</span><br><span class="line"></span><br><span class="line">    HashSet&lt;String&gt; paths = watch2Paths.get(watcher);</span><br><span class="line">    <span class="keyword">if</span> (paths == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// cnxns typically have many watches, so use default cap here</span></span><br><span class="line">        paths = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        watch2Paths.put(watcher, paths);</span><br><span class="line">    &#125;</span><br><span class="line">    paths.add(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最后会将请求中的path放到<code>WatchManager#watch2Paths</code>，将<code>NettyServerCnxn</code>放到<code>WatchManager#watchTable</code>中</p>
<ul>
<li>watchTable:从数据节点<strong>路径</strong>的角度托管<code>Watcher</code>,也就是哪个路径有哪些<code>Watcher</code></li>
<li>watch2Paths:从<code>Watcher</code>角度托管数据节点路径，也就是一个事件发生了，触发指定的数据节点路径</li>
</ul>
<h3 id="触发watcher"><a href="#触发watcher" class="headerlink" title="触发watcher"></a>触发watcher</h3><p>对于标记了有watcher监听的请求，zookeeper会将这条连接<code>ServerCnxn</code>存储到<code>WatchManager</code>中，接下来看看服务端如何触发事件，上边我们是在客户端的<code>getData</code>方法中注册的<code>Watcher</code>，所以我们去看下<code>DataTree#setData</code>方法吧，针对数据变动嘛</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">setData</span><span class="params">(String path, <span class="keyword">byte</span> data[], <span class="keyword">int</span> version, <span class="keyword">long</span> zxid,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">long</span> time)</span> <span class="keyword">throws</span> KeeperException.NoNodeException </span>&#123;</span><br><span class="line">	Stat s = <span class="keyword">new</span> Stat();</span><br><span class="line">	DataNode n = nodes.get(path);</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">byte</span> lastdata[] = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">synchronized</span> (n) &#123;</span><br><span class="line">		lastdata = n.data;</span><br><span class="line">		n.data = data;</span><br><span class="line">		n.stat.setMtime(time);</span><br><span class="line">		n.stat.setMzxid(zxid);</span><br><span class="line">		n.stat.setVersion(version);</span><br><span class="line">		n.copyStat(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// now update if the path is in a quota subtree.</span></span><br><span class="line">	String lastPrefix;</span><br><span class="line">	<span class="keyword">if</span>((lastPrefix = getMaxPrefixWithQuota(path)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">	  <span class="keyword">this</span>.updateBytes(lastPrefix, (data == <span class="keyword">null</span> ? <span class="number">0</span> : data.length)</span><br><span class="line">		  - (lastdata == <span class="keyword">null</span> ? <span class="number">0</span> : lastdata.length));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里</span></span><br><span class="line">	dataWatches.triggerWatch(path, EventType.NodeDataChanged);</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在服务端对指定节点更新数据后，会触发<code>Watcher</code>，这里<code>WatchManager#triggerWatch</code>起的就是这个作用，看下这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Watcher&gt; <span class="title">triggerWatch</span><span class="params">(String path, EventType type, Set&lt;Watcher&gt; supress)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1</span></span><br><span class="line">	WatchedEvent e = <span class="keyword">new</span> WatchedEvent(type, KeeperState.SyncConnected, path);</span><br><span class="line">	HashSet&lt;Watcher&gt; watchers;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="comment">// 2</span></span><br><span class="line">		watchers = watchTable.remove(path);</span><br><span class="line">		<span class="keyword">if</span> (watchers == <span class="keyword">null</span> || watchers.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">				ZooTrace.logTraceMessage(LOG,</span><br><span class="line">						ZooTrace.EVENT_DELIVERY_TRACE_MASK,</span><br><span class="line">						<span class="string">&quot;No watchers for &quot;</span> + path);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (Watcher w : watchers) &#123;</span><br><span class="line">			HashSet&lt;String&gt; paths = watch2Paths.get(w);</span><br><span class="line">			<span class="keyword">if</span> (paths != <span class="keyword">null</span>) &#123;</span><br><span class="line">				paths.remove(path);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3</span></span><br><span class="line">	<span class="keyword">for</span> (Watcher w : watchers) &#123;</span><br><span class="line">		<span class="keyword">if</span> (supress != <span class="keyword">null</span> &amp;&amp; supress.contains(w)) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		w.process(e);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> watchers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码做了三件事</p>
<ul>
<li>封装<code>WatchedEvent</code></li>
<li>提取Watcher:根据节点路径从watchTable中获得对应地Watcher,如果没有，说明没有任何客户端要监听该数据节点，直接退出，如果找到了，则提取出来，并和在<code>watchTable</code>和<code>watch2Paths</code>一并删除路径和<code>Watcher</code>，从这看出<code>Watcher</code>在服务端是<strong>一次性</strong>的，触发一次就失效。</li>
<li>调用<code>Watcher(ServerCnxn实例)</code>的process方法</li>
</ul>
<p>这里就看<code>NettyServerCnxn</code>的process方法吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">	ReplyHeader h = <span class="keyword">new</span> ReplyHeader(-<span class="number">1</span>, -<span class="number">1L</span>, <span class="number">0</span>);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Convert WatchedEvent to a type that can be sent over the wire</span></span><br><span class="line">	WatcherEvent e = event.getWrapper();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		sendResponse(h, e, <span class="string">&quot;notification&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">		<span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">			LOG.debug(<span class="string">&quot;Problem sending to &quot;</span> + getRemoteSocketAddress(), e1);</span><br><span class="line">		&#125;</span><br><span class="line">		close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的作用是</p>
<ul>
<li>封装<code>ReplyHeader</code>，xid赋值为<code>-1</code>表示该响应是个事件通知</li>
<li>将不能网络传输的<code>WatchedEvent</code>包装成可以网络传输的<code>WatcherEvent</code></li>
<li>向客户端发送通知</li>
</ul>
<p>到这我们发现服务端并不处理客户端的真正<code>Watcher</code>业务逻辑，而是借助<code>ServerCnxn</code>传递触发的事件，让客户端去自己处理实际业务</p>
<h2 id="客户端回调Watcher"><a href="#客户端回调Watcher" class="headerlink" title="客户端回调Watcher"></a>客户端回调Watcher</h2><p>通过上边知道服务端触发事件后会通过<code>ServerCnxn</code>向客户端传递事件<code>WatcherEvent</code>，然后看下客户端如何处理进行实际的事件处理</p>
<h3 id="SendThread接收事件通知"><a href="#SendThread接收事件通知" class="headerlink" title="SendThread接收事件通知"></a>SendThread接收事件通知</h3><p>ClientCnxn$SendThread#readResponse方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readResponse</span><span class="params">(ByteBuffer incomingBuffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ByteBufferInputStream bbis = <span class="keyword">new</span> ByteBufferInputStream(</span><br><span class="line">            incomingBuffer);</span><br><span class="line">    BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);</span><br><span class="line">    ReplyHeader replyHdr = <span class="keyword">new</span> ReplyHeader();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    replyHdr.deserialize(bbia, <span class="string">&quot;header&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (replyHdr.getXid() == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// -1 means notification</span></span><br><span class="line">        ...</span><br><span class="line">        WatcherEvent event = <span class="keyword">new</span> WatcherEvent();</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        event.deserialize(bbia, <span class="string">&quot;response&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// convert from a server path to a client path</span></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (chrootPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String serverPath = event.getPath();</span><br><span class="line">            <span class="keyword">if</span>(serverPath.compareTo(chrootPath)==<span class="number">0</span>)</span><br><span class="line">                event.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (serverPath.length() &gt; chrootPath.length())</span><br><span class="line">                event.setPath(serverPath.substring(chrootPath.length()));</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                LOG.warn(<span class="string">&quot;Got server path &quot;</span> + event.getPath()</span><br><span class="line">                        + <span class="string">&quot; which is too short for chroot path &quot;</span></span><br><span class="line">                        + chrootPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        WatchedEvent we = <span class="keyword">new</span> WatchedEvent(event);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        eventThread.queueEvent( we );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何一个来自服务端的响应，都是由上述方法处理<code>replyHdr.getXid() == -1</code>表示这是服务端对一个事件的响应，可以看出这个部分的逻辑是这样的</p>
<ul>
<li>对response中的序列化数据进行反序列化，这里是反序列化出了<code>ReplyHeader</code>和<code>WatcherEvent</code>实例对象</li>
<li>处理<code>chrootPath</code>，这个就是Curator中创建会话时指定的<code>NameSpace</code>，就是一个根路径，服务端返回全路径地址，这里的作用就是把根路径去掉，生成当前<code>chrootPath</code>的相对路径</li>
<li>之前说过<code>WatchedEvent</code>和<code>WatcherEvent</code>的互转，这里就是在转换，<code>WatcherEvent</code>-&gt;<code>WatchedEvent</code></li>
<li>将<code>WatchedEvent</code>托付给<code>EventThread</code>线程，在下一轮询周期进行<code>Watcher</code>回调</li>
</ul>
<h3 id="EventThread处理事件通知"><a href="#EventThread处理事件通知" class="headerlink" title="EventThread处理事件通知"></a>EventThread处理事件通知</h3><p>看下EventThread的结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxn$EventThread</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventThread</span> <span class="keyword">extends</span> <span class="title">ZooKeeperThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedBlockingQueue&lt;Object&gt; waitingEvents =</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** This is really the queued session state until the event</span></span><br><span class="line"><span class="comment">     * thread actually processes the event and hands it to the watcher.</span></span><br><span class="line"><span class="comment">     * But for all intents and purposes this is the state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> KeeperState sessionState = KeeperState.Disconnected;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> wasKilled = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    EventThread() &#123;</span><br><span class="line">        <span class="keyword">super</span>(makeThreadName(<span class="string">&quot;-EventThread&quot;</span>));</span><br><span class="line">        setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queueEvent</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queuePacket</span><span class="params">(Packet packet)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queueEventOfDeath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        waitingEvents.add(eventOfDeath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上边<code>ClientCnxn$SendThread#readResponse</code>方法中最后调用了<code>eventThread.queueEvent(we)</code>，看下这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxn$EventThread#queueEvent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queueEvent</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.getType() == EventType.None</span><br><span class="line">            &amp;&amp; sessionState == event.getState()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sessionState = event.getState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// materialize the watchers based on the event</span></span><br><span class="line">    WatcherSetEventPair pair = <span class="keyword">new</span> WatcherSetEventPair(</span><br><span class="line">            watcher.materialize(event.getState(), event.getType(), event.getPath())</span><br><span class="line">            , event);</span><br><span class="line">    <span class="comment">// queue the pair (watch set &amp; event) for later processing</span></span><br><span class="line">    waitingEvents.add(pair);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先判断客户端和服务端连接状态一致，然后如果事件类型是<code>EventType.None</code>则直接返回；然后看下materialize方法做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCncx$EventThread#materialize</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Watcher&gt; <span class="title">materialize</span><span class="params">(Watcher.Event.KeeperState state, Watcher.Event.EventType type, String clientPath)</span> </span>&#123;</span><br><span class="line">        Set&lt;Watcher&gt; result = <span class="keyword">new</span> HashSet&lt;Watcher&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> None:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">        <span class="keyword">case</span> NodeCreated:</span><br><span class="line">            <span class="keyword">synchronized</span> (dataWatches) &#123;</span><br><span class="line">                addTo(dataWatches.remove(clientPath), result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (existWatches) &#123;</span><br><span class="line">                addTo(existWatches.remove(clientPath), result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NodeChildrenChanged:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> NodeDeleted:</span><br><span class="line">           ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里看出，客户端在识别特定事件类型后会在<code>ZKWatchManager</code>中从相应的warcher存储(dataWatches、existWatches、childWatches)中删除watcher，这也表明客户端对事件的响应是<strong>一次性</strong>的。<br>从这个方法出来再看下<code>WatcherSetEventPair</code>这个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxn$WatcherSetEventPair</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WatcherSetEventPair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Watcher&gt; watchers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchedEvent event;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WatcherSetEventPair</span><span class="params">(Set&lt;Watcher&gt; watchers, WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.watchers = watchers;</span><br><span class="line">        <span class="keyword">this</span>.event = event;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个内部类很简单，封装了事件和对应的watcher。看<code>ClientCnxn$EventThread#queueEvent</code>最后一步<code>waitingEvents.add(pair)</code>，这一步就是放入队列。这个队列是待处理的<code>Watcher</code>，既然有入队，那就应该有处理队列的地方，看<code>ClientCnxn$EventThread#run</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxn$EventThread#run</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      isRunning = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         Object event = waitingEvents.take();</span><br><span class="line">         <span class="keyword">if</span> (event == eventOfDeath) &#123;</span><br><span class="line">            wasKilled = <span class="keyword">true</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            processEvent(event);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (wasKilled)</span><br><span class="line">            <span class="keyword">synchronized</span> (waitingEvents) &#123;</span><br><span class="line">               <span class="keyword">if</span> (waitingEvents.isEmpty()) &#123;</span><br><span class="line">                  isRunning = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      LOG.error(<span class="string">&quot;Event thread exiting due to interruption&quot;</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这是一个死循环，不停处理watcher队列中的事件。这里的<code>processEvent(event)</code>是真正执行我们自己业务逻辑的地方。来看下这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxn$EventThread#processEvent</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (event <span class="keyword">instanceof</span> WatcherSetEventPair) &#123;</span><br><span class="line">              <span class="comment">// each watcher will process the event</span></span><br><span class="line">              WatcherSetEventPair pair = (WatcherSetEventPair) event;</span><br><span class="line">              <span class="keyword">for</span> (Watcher watcher : pair.watchers) &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">// 这里</span></span><br><span class="line">                      watcher.process(pair.event);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                      LOG.error(<span class="string">&quot;Error while calling watcher &quot;</span>, t);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              Packet p = (Packet) event;</span><br><span class="line">              <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">              String clientPath = p.clientPath;</span><br><span class="line">              <span class="keyword">if</span> (p.replyHeader.getErr() != <span class="number">0</span>) &#123;</span><br><span class="line">                  rc = p.replyHeader.getErr();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (p.cb == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  LOG.warn(<span class="string">&quot;Somehow a null cb got to EventThread!&quot;</span>);</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> ExistsResponse</span><br><span class="line">                      || p.response <span class="keyword">instanceof</span> SetDataResponse</span><br><span class="line">                      || p.response <span class="keyword">instanceof</span> SetACLResponse) &#123;</span><br><span class="line">                  StatCallback cb = (StatCallback) p.cb;</span><br><span class="line">                  <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> ExistsResponse) &#123;</span><br><span class="line">                          cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                                  ((ExistsResponse) p.response)</span><br><span class="line">                                          .getStat());</span><br><span class="line">                      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> SetDataResponse) &#123;</span><br><span class="line">                          cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                                  ((SetDataResponse) p.response)</span><br><span class="line">                                          .getStat());</span><br><span class="line">                      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> SetACLResponse) &#123;</span><br><span class="line">                          cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                                  ((SetACLResponse) p.response)</span><br><span class="line">                                          .getStat());</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      cb.processResult(rc, clientPath, p.ctx, <span class="keyword">null</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> GetDataResponse) &#123;</span><br><span class="line">                  DataCallback cb = (DataCallback) p.cb;</span><br><span class="line">                  GetDataResponse rsp = (GetDataResponse) p.response;</span><br><span class="line">                  <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">                      cb.processResult(rc, clientPath, p.ctx, rsp</span><br><span class="line">                              .getData(), rsp.getStat());</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      cb.processResult(rc, clientPath, p.ctx, <span class="keyword">null</span>,</span><br><span class="line">                              <span class="keyword">null</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> GetACLResponse) &#123;</span><br><span class="line">                  ACLCallback cb = (ACLCallback) p.cb;</span><br><span class="line">                  GetACLResponse rsp = (GetACLResponse) p.response;</span><br><span class="line">                  <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">                      cb.processResult(rc, clientPath, p.ctx, rsp</span><br><span class="line">                              .getAcl(), rsp.getStat());</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      cb.processResult(rc, clientPath, p.ctx, <span class="keyword">null</span>,</span><br><span class="line">                              <span class="keyword">null</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> GetChildrenResponse) &#123;</span><br><span class="line">                  ChildrenCallback cb = (ChildrenCallback) p.cb;</span><br><span class="line">                  GetChildrenResponse rsp = (GetChildrenResponse) p.response;</span><br><span class="line">                  <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">                      cb.processResult(rc, clientPath, p.ctx, rsp</span><br><span class="line">                              .getChildren());</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      cb.processResult(rc, clientPath, p.ctx, <span class="keyword">null</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> GetChildren2Response) &#123;</span><br><span class="line">                  Children2Callback cb = (Children2Callback) p.cb;</span><br><span class="line">                  GetChildren2Response rsp = (GetChildren2Response) p.response;</span><br><span class="line">                  <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">                      cb.processResult(rc, clientPath, p.ctx, rsp</span><br><span class="line">                              .getChildren(), rsp.getStat());</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      cb.processResult(rc, clientPath, p.ctx, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> CreateResponse) &#123;</span><br><span class="line">                  StringCallback cb = (StringCallback) p.cb;</span><br><span class="line">                  CreateResponse rsp = (CreateResponse) p.response;</span><br><span class="line">                  <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">                      cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                              (chrootPath == <span class="keyword">null</span></span><br><span class="line">                                      ? rsp.getPath()</span><br><span class="line">                                      : rsp.getPath()</span><br><span class="line">                                .substring(chrootPath.length())));</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      cb.processResult(rc, clientPath, p.ctx, <span class="keyword">null</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> MultiResponse) &#123;</span><br><span class="line">                      MultiCallback cb = (MultiCallback) p.cb;</span><br><span class="line">                      MultiResponse rsp = (MultiResponse) p.response;</span><br><span class="line">                      <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">                              List&lt;OpResult&gt; results = rsp.getResultList();</span><br><span class="line">                              <span class="keyword">int</span> newRc = rc;</span><br><span class="line">                              <span class="keyword">for</span> (OpResult result : results) &#123;</span><br><span class="line">                                      <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ErrorResult</span><br><span class="line">                                          &amp;&amp; KeeperException.Code.OK.intValue()</span><br><span class="line">                                              != (newRc = ((ErrorResult) result).getErr())) &#123;</span><br><span class="line">                                              <span class="keyword">break</span>;</span><br><span class="line">                                      &#125;</span><br><span class="line">                              &#125;</span><br><span class="line">                              cb.processResult(newRc, clientPath, p.ctx, results);</span><br><span class="line">                      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                              cb.processResult(rc, clientPath, p.ctx, <span class="keyword">null</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">              &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (p.cb <span class="keyword">instanceof</span> VoidCallback) &#123;</span><br><span class="line">                  VoidCallback cb = (VoidCallback) p.cb;</span><br><span class="line">                  cb.processResult(rc, clientPath, p.ctx);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          LOG.error(<span class="string">&quot;Caught unexpected throwable&quot;</span>, t);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这个方法，我想起之前zookeeper的api</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getData(<span class="keyword">final</span> String path, Watcher watcher, Stat stat)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(String path, <span class="keyword">boolean</span> watch, DataCallback cb, Object ctx)</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到这里的两个大分支是对这两类api的处理，带<code>Watcher</code>的和带<code>Callback</code>的，这里就是真正调用我们业务的地方，该响应事件的响应事件，该完成异步回调的完成异步回调。</p>
<p>到这里，watcher机制就完事了。</p>
<h1 id="Watcher机制总结"><a href="#Watcher机制总结" class="headerlink" title="Watcher机制总结"></a>Watcher机制总结</h1><p>zookeeper的wathcer机制分为三部分<code>客户端注册watcher</code>，<code>服务端处理watcher</code>，<code>客户端回调watcher</code>，有几个特性，如下</p>
<ul>
<li>Watcher一次性使用:从服务端代码<code>WatchManager#triggerWatch</code>和客户端代码<code>ClientCncx$EventThread#materialize</code>都能看出一个事件一旦触发，就会从对应的存储中删除。zookeeper这么设计的原因是因为在某些更新非常频繁的点服务端会不断向客户端发送通知，这对性能和网络影响很大。所以我们在使用原生api的时候要重复注册watcher。</li>
<li>客户端串行化执行:从<code>ClientCnxn$EventThread#run</code>这里能看出是循环依次处理队列中的watcher</li>
<li>事件传递轻量化:<code>Watcher</code>机制中最小<strong>通知</strong>(<code>Packet</code>是zookeeper最小<strong>通信</strong>单元)单元是<code>WatchedEvent</code>，这个类只封装了路径、连接状态和事件类型，客户端不注册具体<code>Watcher</code>，服务端不知道具体的<code>Watcher</code>，也就导致zookeeper服务端只会告诉客户端这个节点发生了这个事件，具体数据变成什么样客户端你自己再来取吧</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/08/23/zookeeper%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E6%89%AB%E7%9B%B2/" data-id="ckjr4ve0w009bf0ukalvg0nwd" data-title="zookeeper通知机制扫盲" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/" rel="tag">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-zookeeper数据模型扫盲" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/08/22/zookeeper%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E6%89%AB%E7%9B%B2/" class="article-date">
  <time class="dt-published" datetime="2018-08-22T13:53:20.000Z" itemprop="datePublished">2018-08-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/zookeeper/">zookeeper</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/08/22/zookeeper%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E6%89%AB%E7%9B%B2/">zookeeper数据模型扫盲</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h1><p>源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataNode</span> <span class="keyword">implements</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 父节点</span></span><br><span class="line">    DataNode parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点数据</span></span><br><span class="line">    <span class="keyword">byte</span> data[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 权限级别</span></span><br><span class="line">    Long acl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点状态信息</span></span><br><span class="line">    <span class="keyword">public</span> StatPersisted stat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子节点路径，不包含当前节点路径</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; children = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h1><p>这些<code>DataNode</code>组合在一起构成了<code>DataTree</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This hashtable provides a fast lookup to the datanodes. The tree is the</span></span><br><span class="line"><span class="comment">     * source of truth and is where all the locking occurs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="comment">// 节点路径和节点数据组成的map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, DataNode&gt; nodes =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, DataNode&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 数据变动时的watcher</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchManager dataWatches = <span class="keyword">new</span> WatchManager();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子节点变动时的watcher</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchManager childWatches = <span class="keyword">new</span> WatchManager();</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临时节点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, HashSet&lt;String&gt;&gt; ephemerals =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;Long, HashSet&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>zookeeper每一个节点被称为<code>ZNode</code>，所有<code>ZNode</code>按照层级化结构进行组织，形成一棵树。由一系列斜杠<code>/</code>进行分割的路径表示，开发者可以向这个节点写入数据，也可以向这个节点创建子节点。</p>
<p><img src="http://file.ornobug.top/znode%E7%BB%93%E6%9E%84.png" alt="ZNode结构图" title="ZNode结构图"></p>
<h1 id="ZKDatabase"><a href="#ZKDatabase" class="headerlink" title="ZKDatabase"></a>ZKDatabase</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKDatabase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(ZKDatabase.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * make sure on a clear you take care of</span></span><br><span class="line"><span class="comment">     * all these members.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> DataTree dataTree;</span><br><span class="line">    <span class="comment">// 过期会话集合 sessionId-超时时间</span></span><br><span class="line">    <span class="keyword">protected</span> ConcurrentHashMap&lt;Long, Integer&gt; sessionsWithTimeouts;</span><br><span class="line">    <span class="comment">// 事务日志快照</span></span><br><span class="line">    <span class="keyword">protected</span> FileTxnSnapLog snapLog;</span><br><span class="line">    <span class="comment">// 内存中最大，最小的已经被提交的zxid</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> minCommittedLog, maxCommittedLog;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> commitLogCount = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> commitLogBuffer = <span class="number">700</span>;</span><br><span class="line">    <span class="comment">// 提交过的提案集合</span></span><br><span class="line">    <span class="keyword">protected</span> LinkedList&lt;Proposal&gt; committedLog = <span class="keyword">new</span> LinkedList&lt;Proposal&gt;();</span><br><span class="line">    <span class="keyword">protected</span> ReentrantReadWriteLock logLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">private</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ZKDatabase</code>是<code>zookeeper</code>的内存数据库，负责管理<code>zookeeper</code>的所有会话、<code>DataTree</code>和事务日志。<code>ZKDatabase</code>会定时向磁盘dump快照数据，在<code>Zookeeper</code>服务端启动的时候，会通过磁盘上的事务日志和快照数据文件恢复完整的内存数据库。</p>
<h1 id="节点类型CreateMode"><a href="#节点类型CreateMode" class="headerlink" title="节点类型CreateMode"></a>节点类型CreateMode</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CreateMode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The znode will not be automatically deleted upon client&#x27;s disconnect.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 持久型，被创建后除非有删除操作，否则一直存在于服务器上</span></span><br><span class="line">    PERSISTENT (<span class="number">0</span>, <span class="keyword">false</span>, <span class="keyword">false</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The znode will not be automatically deleted upon client&#x27;s disconnect,</span></span><br><span class="line"><span class="comment">    * and its name will be appended with a monotonically increasing number.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 持久有序型，在持久型的基础上，增加了顺序性的特性，</span></span><br><span class="line">    <span class="comment">// 在创建节点过程中会为节点名自动加上数字后缀，最大为Integer.MAX_VALUE</span></span><br><span class="line">    PERSISTENT_SEQUENTIAL (<span class="number">2</span>, <span class="keyword">false</span>, <span class="keyword">true</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The znode will be deleted upon the client&#x27;s disconnect.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 临时节点，临时节点的生命周期和会话绑定在一起，客户端会话失效会删除节点</span></span><br><span class="line">    <span class="comment">// 这里客户端会话失效为不是TCP断开连接</span></span><br><span class="line">    <span class="comment">// zookeeper的父节点不能是临时节点</span></span><br><span class="line">    EPHEMERAL (<span class="number">1</span>, <span class="keyword">true</span>, <span class="keyword">false</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The znode will be deleted upon the client&#x27;s disconnect, and its name</span></span><br><span class="line"><span class="comment">     * will be appended with a monotonically increasing number.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 临时有序节点，在临时节点的基础上增加了有序性</span></span><br><span class="line">    EPHEMERAL_SEQUENTIAL (<span class="number">3</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="节点状态信息StatPersisted"><a href="#节点状态信息StatPersisted" class="headerlink" title="节点状态信息StatPersisted"></a>节点状态信息StatPersisted</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatPersisted</span> <span class="keyword">implements</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Created ZXID 表示该数据节点被创建时的事务ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> czxid;</span><br><span class="line">    <span class="comment">// Modified ZXID 表示该节点最后一次被更新时的事务ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mzxid;</span><br><span class="line">    <span class="comment">// Create Time 表示节点被创建时的事件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> ctime;</span><br><span class="line">    <span class="comment">// Modified Time 表示该节点最后一次被更新时的时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mtime;</span><br><span class="line">    <span class="comment">// 数据节点版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line">    <span class="comment">// 子节点版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cversion;</span><br><span class="line">    <span class="comment">// 节点的ACL版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> aversion;</span><br><span class="line">    <span class="comment">// 创建该临时节点的会话的SessionId,如果节点是持久的，则该值为0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> ephemeralOwner;</span><br><span class="line">    <span class="comment">// 表示该节点的子节点列表最后一次被更新时的事务ID,子节点列表更新会影响该值，子节点数据更新并不会</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> pzxid;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h1 id="版本-保证分布式数据原子操作"><a href="#版本-保证分布式数据原子操作" class="headerlink" title="版本-保证分布式数据原子操作"></a>版本-保证分布式数据原子操作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StatPersisted类</span></span><br><span class="line"><span class="comment">// 数据节点版本号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line"><span class="comment">// 子节点版本号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cversion;</span><br><span class="line"><span class="comment">// 节点的ACL版本号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> aversion;</span><br></pre></td></tr></table></figure>
<p>这里的版本似的是对<strong>数据节点、子节点列表、节点的ACL</strong>的修改次数，就算前后两次修改，导致结果一样，但是<strong>版本还是会加上去</strong><br>为应对分布式系统中的高性能并发修改问题，zookeeper使用的是<strong>乐观锁</strong>，乐观锁控制事务分成三个阶段：<code>数据读取</code>,<code>写入校验</code>,<code>数据写入</code>。<strong>写入校验</strong>是关键，写入校验时事务会检查数据在读取阶段后是否有其他事务对数据进行过更新，以确保数据更新的一致性。<br>JDK的CAS操作:对于值V,每次更新前都会对比其值是否为预期值A，只有符合预期，才能写入。是否符合预期值便是乐观锁的写入校验，<strong>此时的version就是预期值</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/08/22/zookeeper%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E6%89%AB%E7%9B%B2/" data-id="ckjr4vdze002of0uk5m5zcm8q" data-title="zookeeper数据模型扫盲" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/" rel="tag">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-curator其他应用场景" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/08/22/curator%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/" class="article-date">
  <time class="dt-published" datetime="2018-08-22T13:03:51.000Z" itemprop="datePublished">2018-08-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/zookeeper/">zookeeper</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/08/22/curator%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/">curator其他应用场景</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>之前的zookeeper原生api/zkclient api/curator api使用示例</p>
<p><a target="_blank" rel="noopener" href="https://github.com/lzm1988/zkdemo">https://github.com/lzm1988/zkdemo</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/08/22/curator%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/" data-id="ckjr4vdyp000bf0uk39xc82v0" data-title="curator其他应用场景" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/" rel="tag">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/activemq/">activemq</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hadoop/">hadoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jvm/">jvm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/zookeeper/">zookeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%BF%97/">日志</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AE%E5%AD%90/">轮子</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%80%9A%E8%AF%86/">通识</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CountDownLatch/" rel="tag">CountDownLatch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CyclicBarrier/" rel="tag">CyclicBarrier</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReentrantLock/" rel="tag">ReentrantLock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReentrantReadWriteLock/" rel="tag">ReentrantReadWriteLock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ThreadLocal/" rel="tag">ThreadLocal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/activemq/" rel="tag">activemq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cas%E6%93%8D%E4%BD%9C/" rel="tag">cas操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cron/" rel="tag">cron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fork-join%E6%A1%86%E6%9E%B6/" rel="tag">fork/join框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/freemark/" rel="tag">freemark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/" rel="tag">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/" rel="tag">jvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm%EF%BC%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="tag">jvm，垃圾回收</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/log4j/" rel="tag">log4j</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/protobuf/" rel="tag">protobuf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/quartz/" rel="tag">quartz</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet3/" rel="tag">servlet3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/" rel="tag">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web-xml/" rel="tag">web.xml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zookeeper/" rel="tag">zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" rel="tag">主从复制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" rel="tag">单例模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">基础线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" rel="tag">布隆过滤器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E7%B1%BB/" rel="tag">并发集合类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2/" rel="tag">搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96/" rel="tag">数字格式化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A0%E9%94%81/" rel="tag">无锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/" rel="tag">日期格式化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%9B%E5%9E%8B/" rel="tag">泛型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E5%B7%A5%E5%85%B7/" rel="tag">线程阻塞工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AE%E5%AD%90/" rel="tag">轮子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E8%AF%86/" rel="tag">通识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81%E4%BC%98%E5%8C%96/" rel="tag">锁优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CountDownLatch/" style="font-size: 10px;">CountDownLatch</a> <a href="/tags/CyclicBarrier/" style="font-size: 10px;">CyclicBarrier</a> <a href="/tags/ReentrantLock/" style="font-size: 10px;">ReentrantLock</a> <a href="/tags/ReentrantReadWriteLock/" style="font-size: 10px;">ReentrantReadWriteLock</a> <a href="/tags/ThreadLocal/" style="font-size: 10px;">ThreadLocal</a> <a href="/tags/activemq/" style="font-size: 10px;">activemq</a> <a href="/tags/cas%E6%93%8D%E4%BD%9C/" style="font-size: 10px;">cas操作</a> <a href="/tags/cron/" style="font-size: 10px;">cron</a> <a href="/tags/fork-join%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">fork/join框架</a> <a href="/tags/freemark/" style="font-size: 10px;">freemark</a> <a href="/tags/hadoop/" style="font-size: 12px;">hadoop</a> <a href="/tags/js/" style="font-size: 14px;">js</a> <a href="/tags/jvm/" style="font-size: 10px;">jvm</a> <a href="/tags/jvm%EF%BC%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" style="font-size: 12px;">jvm，垃圾回收</a> <a href="/tags/linux/" style="font-size: 16px;">linux</a> <a href="/tags/log4j/" style="font-size: 10px;">log4j</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mysql/" style="font-size: 14px;">mysql</a> <a href="/tags/protobuf/" style="font-size: 10px;">protobuf</a> <a href="/tags/quartz/" style="font-size: 12px;">quartz</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/servlet3/" style="font-size: 10px;">servlet3</a> <a href="/tags/spring/" style="font-size: 12px;">spring</a> <a href="/tags/springboot/" style="font-size: 10px;">springboot</a> <a href="/tags/tomcat/" style="font-size: 10px;">tomcat</a> <a href="/tags/web-xml/" style="font-size: 10px;">web.xml</a> <a href="/tags/zookeeper/" style="font-size: 20px;">zookeeper</a> <a href="/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" style="font-size: 10px;">主从复制</a> <a href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">单例模式</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 10px;">基础线程池</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 18px;">多线程</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 10px;">字符串</a> <a href="/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" style="font-size: 10px;">布隆过滤器</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E7%B1%BB/" style="font-size: 10px;">并发集合类</a> <a href="/tags/%E6%90%9C%E7%B4%A2/" style="font-size: 10px;">搜索</a> <a href="/tags/%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96/" style="font-size: 12px;">数字格式化</a> <a href="/tags/%E6%97%A0%E9%94%81/" style="font-size: 10px;">无锁</a> <a href="/tags/%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/" style="font-size: 10px;">日期格式化</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 10px;">泛型</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 10px;">线程池</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">线程阻塞工具</a> <a href="/tags/%E8%BD%AE%E5%AD%90/" style="font-size: 10px;">轮子</a> <a href="/tags/%E9%80%9A%E8%AF%86/" style="font-size: 10px;">通识</a> <a href="/tags/%E9%94%81%E4%BC%98%E5%8C%96/" style="font-size: 12px;">锁优化</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/10/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/12/24/federation%E6%A8%A1%E5%BC%8F%E7%9A%84hadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/">federation模式的hadoop集群搭建</a>
          </li>
        
          <li>
            <a href="/2018/12/16/hadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/">hadoop集群搭建</a>
          </li>
        
          <li>
            <a href="/2018/10/26/linux-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/">linux-文件管理</a>
          </li>
        
          <li>
            <a href="/2018/10/25/%E6%98%9F%E6%9C%9F%E6%9C%88%E4%BB%BD%E8%8B%B1%E6%96%87%E7%BC%A9%E5%86%99/">星期月份英文缩写</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>